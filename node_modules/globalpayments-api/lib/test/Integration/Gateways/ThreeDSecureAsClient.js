"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ThreeDSecureAcsClient = void 0;
const src_1 = require("../../../src");
const AcsResponse_1 = require("./AcsResponse");
const https_1 = require("https");
class ThreeDSecureAcsClient {
    serviceUrl;
    gatewayProvider;
    authenticationResultCode;
    constructor(url) {
        this.serviceUrl = new URL(url);
    }
    getGatewayProvider() {
        return this.gatewayProvider;
    }
    setGatewayProvider(value) {
        this.gatewayProvider = value;
    }
    async authenticate_v2(secureEcom) {
        let kvps = [];
        let postData;
        const header = [
            "Content-Type: application/x-www-form-urlencoded",
            "cache-control: no-cache",
        ];
        const verb = "POST";
        let rawResponse;
        switch (this.gatewayProvider) {
            case src_1.GatewayProvider.GpEcom:
            case src_1.GatewayProvider.GpApi:
                const messageType = this.gatewayProvider === src_1.GatewayProvider.GpApi
                    ? secureEcom.messageType
                    : "creq";
                kvps.push({
                    key: messageType,
                    value: encodeURIComponent(secureEcom.payerAuthenticationRequest),
                });
                postData = this.buildData(kvps);
                await this.sendRequest(verb, postData, header);
                kvps = [{ key: "get-status-type", value: "true" }];
                do {
                    postData = this.buildData(kvps);
                    rawResponse = await this.sendRequest(verb, postData, header);
                    await new Promise((res) => setTimeout(res, 5000));
                } while (rawResponse.trim() === "IN_PROGRESS");
                rawResponse = await this.sendRequest(verb, "", header);
                kvps = [];
                const cres = this.getInputValue(rawResponse, "cres");
                kvps.push({ key: "cres", value: encodeURIComponent(cres) });
                postData = this.buildData(kvps);
                this.serviceUrl = new URL(this.getInputValue(rawResponse, undefined, "ResForm"));
                rawResponse = await this.sendRequest(verb, postData, header);
                const rValue = new AcsResponse_1.AcsResponse();
                let status = false;
                if (src_1.StringUtils.isJson(rawResponse)) {
                    const parsedResponse = JSON.parse(rawResponse);
                    status = !!parsedResponse.success;
                }
                rValue.setStatus(status);
                if (cres) {
                    const acsDecodedRS = JSON.parse(atob(cres));
                    if (acsDecodedRS.threeDSServerTransID) {
                        rValue.setMerchantData(acsDecodedRS.threeDSServerTransID);
                    }
                }
                return rValue;
            default:
                return false;
        }
    }
    async authenticate_v1(secureEcom) {
        let kvps = [];
        let postData;
        const header = [
            "Content-Type: application/x-www-form-urlencoded",
            "cache-control: no-cache",
        ];
        const verb = "POST";
        let rawResponse;
        switch (this.gatewayProvider) {
            case src_1.GatewayProvider.GpApi:
                kvps.push({
                    key: "TermUrl",
                    value: encodeURIComponent(secureEcom.challengeReturnUrl),
                });
                kvps.push({
                    key: secureEcom.sessionDataFieldName,
                    value: secureEcom.serverTransactionId,
                });
                kvps.push({
                    key: secureEcom.messageType,
                    value: encodeURIComponent(secureEcom.payerAuthenticationRequest),
                });
                kvps.push({
                    key: "AuthenticationResultCode",
                    value: this.authenticationResultCode,
                });
                postData = this.buildData(kvps);
                rawResponse = await this.sendRequest(verb, postData, header);
                kvps = [];
                const paRes = this.getInputValue(rawResponse, "PaRes");
                kvps.push({ key: "PaRes", value: encodeURIComponent(paRes) });
                kvps.push({ key: "MD", value: this.getInputValue(rawResponse, "MD") });
                postData = this.buildData(kvps);
                this.serviceUrl = new URL(this.getInputValue(rawResponse, undefined, "PAResForm"));
                const rawResponse2 = await this.sendRequest(verb, postData, header);
                const rValue = new AcsResponse_1.AcsResponse();
                if (src_1.StringUtils.isJson(rawResponse2)) {
                    const parsedResponse = JSON.parse(rawResponse2);
                    rValue.setStatus(!!parsedResponse.success);
                    rValue.setAuthResponse(paRes);
                    rValue.setMerchantData(this.getInputValue(rawResponse, "MD"));
                }
                return rValue;
            default:
                return false;
        }
    }
    async authenticate(payerAuthRequest, merchantData = "") {
        const kvps = [];
        let postData;
        const header = [
            "Content-Type: application/x-www-form-urlencoded",
            "cache-control: no-cache",
        ];
        const verb = "POST";
        let rawResponse;
        switch (this.gatewayProvider) {
            case src_1.GatewayProvider.GpEcom:
                kvps.push({
                    key: "PaReq",
                    value: encodeURIComponent(payerAuthRequest),
                });
                kvps.push({
                    key: "TermUrl",
                    value: encodeURIComponent("https://www.mywebsite.com/process3dSecure"),
                });
                kvps.push({ key: "MD", value: encodeURIComponent(merchantData) });
                postData = this.buildData(kvps);
                rawResponse = await this.sendRequest(verb, postData, header);
                const rValue = new AcsResponse_1.AcsResponse();
                rValue.setAuthResponse(this.getInputValue(rawResponse, "PaRes"));
                rValue.setMerchantData(this.getInputValue(rawResponse, "MD"));
                return rValue;
            default:
                return false;
        }
    }
    async sendRequest(verb, data, headers) {
        return new Promise((resolve, reject) => {
            /* eslint-disable */
            const mappedHeaders = headers.reduce((acc, header) => {
                const [key, value] = header.split(": ");
                acc[key] = value;
                return acc;
            }, {});
            /* eslint-enable  */
            const req = (0, https_1.request)({
                host: this.serviceUrl.hostname,
                path: this.serviceUrl.pathname,
                method: verb,
                headers: mappedHeaders,
            }, (res) => {
                let responseBody = "";
                // Listen for data chunks
                res.on("data", (chunk) => {
                    responseBody += chunk;
                });
                // Handle the end of the response
                res.on("end", () => {
                    resolve(responseBody);
                });
            });
            // Handle request errors
            req.on("error", (error) => {
                reject(new src_1.ApiError(`Acs request failed with message: ${error.message}`));
            });
            // Write data to request body
            req.write(data);
            // End the request
            req.end();
        });
    }
    buildData(kvps) {
        return kvps.map((kvp) => `${kvp.key}=${kvp.value}`).join("&");
    }
    getInputValue(raw, inputValue, formName) {
        if (!raw) {
            return "";
        }
        let searchString;
        if (inputValue) {
            searchString = `name="${inputValue}" value="`;
        }
        else if (formName) {
            searchString = `name="${formName}" action="`;
        }
        else {
            return "";
        }
        const index = raw.indexOf(searchString);
        if (index > -1) {
            const startIndex = index + searchString.length;
            const length = raw.indexOf('"', startIndex) - startIndex;
            return raw.substring(startIndex, startIndex + length);
        }
        return "";
    }
}
exports.ThreeDSecureAcsClient = ThreeDSecureAcsClient;
//# sourceMappingURL=ThreeDSecureAsClient.js.map