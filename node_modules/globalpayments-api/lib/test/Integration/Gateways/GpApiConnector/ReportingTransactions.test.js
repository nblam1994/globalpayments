"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const src_1 = require("../../../../src");
const BaseGpApiTestConfig_1 = require("../../../Data/BaseGpApiTestConfig");
const startDate = new Date(), endDate = new Date();
startDate.setDate(startDate.getDate() - 30);
startDate.setHours(0);
startDate.setMinutes(0);
startDate.setSeconds(0);
let batchId;
let amount;
let country;
let currency;
let brandReference;
let reference;
let cardBrand;
let authCode;
let transactionId;
beforeAll(() => {
    src_1.ServicesContainer.configureService(BaseGpApiTestConfig_1.BaseGpApiTestConfig.gpApiSetupConfig(src_1.Channel.CardNotPresent));
});
afterAll(() => BaseGpApiTestConfig_1.BaseGpApiTestConfig.resetGpApiConfig());
test("report find transactions by start date and end date", async () => {
    const response = await src_1.ReportingService.findTransactionsPaged(1, 10)
        .orderBy(src_1.TransactionSortProperty.TIME_CREATED)
        .where(src_1.SearchCriteria.StartDate, startDate)
        .andWith(src_1.SearchCriteria.EndDate, endDate)
        .execute();
    expect(response).toBeTruthy();
    expect(response.result.length > 0).toBe(true);
    for (const transaction of response.result) {
        expect(new Date(transaction.transactionDate).getTime() >= startDate.getTime()).toBe(true);
        expect(new Date(transaction.transactionDate).getTime() < endDate.getTime()).toBe(true);
        transactionId = transaction.transactionId;
        if (!batchId && transaction.batchSequenceNumber) {
            batchId = transaction.batchSequenceNumber;
        }
        if (!amount) {
            amount = transaction.amount;
            country = transaction.country;
            currency = transaction.currency;
        }
        if (!brandReference && transaction.brandReference) {
            brandReference = transaction.brandReference;
        }
        if (!reference) {
            reference = transaction.referenceNumber;
        }
        if (!cardBrand) {
            cardBrand = transaction.cardType;
            authCode = transaction.authCode;
        }
    }
});
test("report find transactions by transactionId", async () => {
    try {
        // transactionId is used from list of transactions in test: report find transactions by start date and end date
        const response = await src_1.ReportingService.findTransactionsPaged(1, 10)
            .withTransactionId(transactionId)
            .where(src_1.SearchCriteria.StartDate, startDate)
            .execute();
        expect(response.result.length === 1).toBe(true);
        expect(transactionId).toBe(response.result[0].transactionId);
    }
    catch (e) {
        console.log(`Find transactions by Id failed: ${e.message}`);
    }
});
test("report find transactions with wrong transactionId", async () => {
    try {
        const response = await src_1.ReportingService.findTransactionsPaged(1, 10)
            .withTransactionId("TRN_B2RDfsrhwhzvsbkci4JdTiZ9mHVmvC")
            .where(src_1.SearchCriteria.StartDate, startDate)
            .execute();
        expect(response.result.length).toBe(0);
    }
    catch (e) {
        console.log(`Find transactions by Id failed: ${e.message}`);
    }
});
test("report find transactions by batchId", async () => {
    try {
        // batchId is used from list of transactions in test: report find transactions by start date and end date
        const response = await src_1.ReportingService.findTransactionsPaged(1, 10)
            .where(src_1.SearchCriteria.StartDate, startDate)
            .andWith(src_1.SearchCriteria.BatchId, batchId)
            .execute();
        expect(response.result.length >= 1).toBe(true);
        for (const transaction of response.result) {
            expect(batchId).toBe(transaction.batchSequenceNumber);
        }
    }
    catch (e) {
        console.log(`Find transactions by Id failed: ${e.message}`);
    }
});
test("report find transactions by payment type", async () => {
    try {
        const paymentType = src_1.PaymentType.SALE;
        const response = await src_1.ReportingService.findTransactionsPaged(1, 10)
            .where(src_1.SearchCriteria.StartDate, startDate)
            .andWith(src_1.SearchCriteria.PaymentType, paymentType)
            .execute();
        expect(response.result.length >= 1).toBe(true);
        for (const transaction of response.result) {
            expect(paymentType).toBe(transaction.transactionType);
        }
    }
    catch (e) {
        console.log(`Find transactions by Id failed: ${e.message}`);
    }
});
test("report find transactions by amount, currency and country", async () => {
    // amount, currency, country is used from list of transactions in test: report find transactions by start date and end date
    try {
        const response = await src_1.ReportingService.findTransactionsPaged(1, 10)
            .where(src_1.SearchCriteria.StartDate, startDate)
            .andWith(src_1.DataServiceCriteria.Amount, amount)
            .andWith(src_1.DataServiceCriteria.Currency, currency)
            .andWith(src_1.DataServiceCriteria.Country, country)
            .execute();
        expect(response.result.length >= 1).toBe(true);
        for (const transaction of response.result) {
            expect(amount).toBe(transaction.amount);
            expect(currency).toBe(transaction.currency);
            expect(country).toBe(transaction.country);
        }
    }
    catch (e) {
        console.log(`Find transactions by Id failed: ${e.message}`);
    }
});
test("report find transactions by Channel", async () => {
    try {
        const channel = src_1.Channel.CardNotPresent;
        const response = await src_1.ReportingService.findTransactionsPaged(1, 10)
            .where(src_1.SearchCriteria.StartDate, startDate)
            .andWith(src_1.SearchCriteria.Channel, channel)
            .execute();
        expect(response.result.length >= 1).toBe(true);
        for (const transaction of response.result) {
            expect(channel).toBe(transaction.channel);
        }
    }
    catch (e) {
        console.log(`Find transactions by Id failed: ${e.message}`);
    }
});
test("report find transactions by status", async () => {
    try {
        const status = src_1.TransactionStatus.CAPTURED;
        const response = await src_1.ReportingService.findTransactionsPaged(1, 10)
            .where(src_1.SearchCriteria.StartDate, startDate)
            .andWith(src_1.SearchCriteria.TransactionStatus, status)
            .execute();
        expect(response.result.length >= 1).toBe(true);
        expect(status).toBe(response.result[0].transactionStatus);
    }
    catch (e) {
        console.log(`Find transactions by Id failed: ${e.message}`);
    }
});
test("report find transactions by card brand and authCode", async () => {
    // authCode, cardBrand is used from list of transactions in test: report find transactions by start date and end date
    try {
        const response = await src_1.ReportingService.findTransactionsPaged(1, 10)
            .where(src_1.SearchCriteria.StartDate, startDate)
            .andWith(src_1.SearchCriteria.CardBrand, cardBrand)
            .andWith(src_1.SearchCriteria.AuthCode, authCode)
            .execute();
        expect(response.result.length >= 1).toBe(true);
        expect(cardBrand).toBe(response.result[0].cardType);
        expect(authCode).toBe(response.result[0].authCode);
    }
    catch (e) {
        console.log(`Find transactions by Id failed: ${e.message}`);
    }
});
test("report find transactions by reference", async () => {
    try {
        const response = await src_1.ReportingService.findTransactionsPaged(1, 10)
            .where(src_1.SearchCriteria.StartDate, startDate)
            .andWith(src_1.SearchCriteria.ReferenceNumber, reference)
            .execute();
        expect(response.result.length >= 1).toBe(true);
        expect(reference).toBe(response.result[0].referenceNumber);
    }
    catch (e) {
        console.log(`Find transactions by Id failed: ${e.message}`);
    }
});
//failed
test("report find transactions by brandReference", async () => {
    const response = await src_1.ReportingService.findTransactionsPaged(1, 10)
        .where(src_1.SearchCriteria.StartDate, startDate)
        .andWith(src_1.SearchCriteria.BrandReference, brandReference)
        .execute();
    expect(response.result.length >= 1).toBe(true);
    for (const transaction of response.result) {
        expect(brandReference).toBe(transaction.brandReference);
    }
});
test("report find transactions by entryMode", async () => {
    const paymentEntryMode = src_1.PaymentEntryMode.ECOM;
    const response = await src_1.ReportingService.findTransactionsPaged(1, 10)
        .where(src_1.SearchCriteria.StartDate, startDate)
        .andWith(src_1.SearchCriteria.PaymentEntryMode, paymentEntryMode)
        .execute();
    expect(response.result.length >= 1).toBe(true);
    expect(paymentEntryMode).toBe(response.result[0].entryMode);
});
test("report find transactions by number first6 and last4", async () => {
    const firstSix = "426397";
    const lastFour = "5262";
    const response = await src_1.ReportingService.findTransactionsPaged(1, 10)
        .where(src_1.SearchCriteria.StartDate, startDate)
        .andWith(src_1.SearchCriteria.CardNumberFirstSix, firstSix)
        .andWith(src_1.SearchCriteria.CardNumberLastFour, lastFour)
        .execute();
    expect(response.result.length >= 1).toBe(true);
    expect(response.result[0].maskedCardNumber.startsWith(firstSix) &&
        response.result[0].maskedCardNumber.endsWith(lastFour)).toBe(true);
});
test("report find transactions by token first6 and last4 and wrong payment method", async () => {
    const firstSix = "426397";
    const lastFour = "5262";
    try {
        await src_1.ReportingService.findTransactionsPaged(1, 10)
            .where(src_1.SearchCriteria.StartDate, startDate)
            .andWith(src_1.SearchCriteria.TokenFirstSix, firstSix)
            .andWith(src_1.SearchCriteria.TokenLastFour, lastFour)
            .andWith(src_1.SearchCriteria.PaymentMethodName, src_1.PaymentMethodName.CARD)
            .execute();
    }
    catch (error) {
        expect(error).toBeTruthy();
        expect(error?.responseCode).toBe("40043");
        expect(error?.message.includes("Status Code: INVALID_REQUEST_DATA - Request contains unexpected fields: payment_method")).toBe(true);
        expect(error instanceof src_1.GatewayError).toBe(true);
    }
});
test("report find transactions by payment method name", async () => {
    const paymentMethodName = src_1.PaymentMethodName.DIGITAL_WALLET;
    const response = await src_1.ReportingService.findTransactionsPaged(1, 10)
        .where(src_1.SearchCriteria.StartDate, startDate)
        .andWith(src_1.SearchCriteria.PaymentMethodName, paymentMethodName)
        .execute();
    expect(response.result.length >= 1).toBe(true);
    expect(paymentMethodName).toBe(response.result[0].paymentType);
});
test("report find transactions by name", async () => {
    const cardHolderName = "James Mason";
    const response = await src_1.ReportingService.findTransactionsPaged(1, 10)
        .where(src_1.SearchCriteria.StartDate, startDate)
        .andWith(src_1.SearchCriteria.Name, cardHolderName)
        .execute();
    expect(response.result.length >= 1).toBe(true);
    expect(cardHolderName).toBe(response.result[0].cardHolderName);
});
test("report find transactions order by Id", async () => {
    const response = await src_1.ReportingService.findTransactionsPaged(1, 10)
        .orderBy(src_1.TransactionSortProperty.ID)
        .where(src_1.SearchCriteria.StartDate, startDate)
        .execute();
    expect(response.result.length > 1).toBe(true);
    let transactions = response.result;
    transactions = transactions.sort((a, b) => {
        return a.transactionId < b.transactionId;
    });
    for (const [index, responseTransaction] of response.result.entries()) {
        expect(responseTransaction.transactionId).toBe(transactions[index].transactionId);
    }
});
test("report find transactions order by Type", async () => {
    const response = await src_1.ReportingService.findTransactionsPaged(1, 10)
        .orderBy(src_1.TransactionSortProperty.TYPE)
        .where(src_1.SearchCriteria.StartDate, startDate)
        .execute();
    expect(response.result.length > 1).toBe(true);
    let transactions = response.result;
    transactions = transactions.sort((a, b) => {
        return a.transactionType < b.transactionType;
    });
    for (const [index, responseTransaction] of response.result.entries()) {
        expect(responseTransaction.transactionType).toBe(transactions[index].transactionType);
    }
});
test("report find transactions order by TimeCreated", async () => {
    const response = await src_1.ReportingService.findTransactionsPaged(1, 10)
        .orderBy(src_1.TransactionSortProperty.TIME_CREATED)
        .where(src_1.SearchCriteria.StartDate, startDate)
        .execute();
    expect(response.result.length > 1).toBe(true);
    let transactions = response.result;
    transactions = transactions.sort((a, b) => {
        return (new Date(a.transactionDate).getTime() <
            new Date(b.transactionDate).getTime());
    });
    for (const [index, responseTransaction] of response.result.entries()) {
        expect(new Date(responseTransaction.transactionDate).getTime()).toBe(new Date(transactions[index].transactionDate).getTime());
    }
});
test("report find transactions without mandatory startDate", async () => {
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - 30);
    startDate.setHours(0);
    startDate.setMinutes(0);
    startDate.setSeconds(0);
    const tonight = new Date();
    tonight.setDate(tonight.getDate() + 1);
    tonight.setHours(0);
    tonight.setMinutes(0);
    tonight.setSeconds(0);
    const response = await src_1.ReportingService.findTransactionsPaged(1, 10).execute();
    expect(response.result.length >= 0).toBe(true);
    for (const transaction of response.result) {
        expect(tonight.getTime() >= new Date(transaction.transactionDate).getTime()).toBe(true);
        expect(tonight.getTime() >= new Date(transaction.transactionDate).getTime()).toBe(true);
    }
});
test("transaction details report", async () => {
    const transactionId = "TRN_RyWZELCUbOq12IPDowbOevTC9BZxZi_6827116a3d1b";
    const response = await src_1.ReportingService.transactionDetail(transactionId).execute();
    expect(response).toBeTruthy();
    expect(response instanceof src_1.TransactionSummary).toBe(true);
    expect(response.transactionId).toBe(transactionId);
});
test("transaction details report - wrong ID", async () => {
    const transactionId = src_1.GenerationUtils.getGuuid();
    try {
        await src_1.ReportingService.transactionDetail(transactionId).execute();
    }
    catch (error) {
        expect(error).toBeTruthy();
        expect(error?.responseCode).toBe("40118");
        expect(error?.message.includes(`Status Code: RESOURCE_NOT_FOUND - Transactions ${transactionId} not found at this /ucp/transactions/${transactionId}`)).toBe(true);
        expect(error instanceof src_1.GatewayError).toBe(true);
    }
});
//# sourceMappingURL=ReportingTransactions.test.js.map