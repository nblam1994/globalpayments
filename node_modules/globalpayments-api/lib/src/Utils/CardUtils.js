"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CardUtils = void 0;
const DTO_1 = require("../../src/Entities/GpApi/DTO");
const src_1 = require("../../src");
class CardUtils {
    static trackOnePattern = /%?[B0]?([\d]+)\\^[^\\^]+\\^([\\d]{4})([^?]+)?/;
    static trackTwoPattern = /;?([\d]+)=([\d]{4})([^?]+)?/;
    static fleetBinMap = {
        Visa: [
            ["448460", "448611"],
            ["448613", "448615"],
            ["448617", "448674"],
            ["448676", "448686"],
            ["448688", "448699"],
            ["461400", "461421"],
            ["461423", "461499"],
            ["480700", "480899"],
        ],
        MC: [
            ["553231", "553380"],
            ["556083", "556099"],
            ["556100", "556599"],
            ["556700", "556999"],
        ],
        Wex: [
            ["690046", "690046"],
            ["707138", "707138"],
        ],
        Voyager: [["708885", "708889"]],
    };
    static cardTypes = {
        Visa: /^4/,
        MC: /^(?:5[1-6]|222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)/,
        Amex: /^3[47]/,
        DinersClub: /^3(?:0[0-5]|[68][0-9])/,
        EnRoute: /^2(014|149)/,
        Discover: /^6(?:011|5[0-9]{2})/,
        Jcb: /^(?:2131|1800|35\d{3})/,
        Wex: /^(?:690046|707138)/,
        Voyager: /^70888[5-9]/,
    };
    static generateCard(builder, gatewayProvider, maskedValues) {
        const paymentMethod = builder.paymentMethod;
        const transactionType = builder.transactionType;
        const card = new DTO_1.Card();
        if (paymentMethod.isTrackData) {
            card.track = paymentMethod.value;
            if (transactionType === src_1.TransactionType.Sale) {
                if (!card.track) {
                    card.number = paymentMethod.pan;
                    maskedValues = {
                        ...maskedValues,
                        ...src_1.ProtectSensitiveData.hideValue("payment_method.card.number", paymentMethod.pan, 4),
                    };
                    if (paymentMethod.expiry) {
                        card.expiry_month = paymentMethod.expiry.substring(2, 4);
                        card.expiry_year = paymentMethod.expiry.substring(0, 2);
                        maskedValues = {
                            ...maskedValues,
                            ...src_1.ProtectSensitiveData.hideValues({
                                "payment_method.card.expiry_month": card.expiry_month,
                                "payment_method.card.expiry_year": card.expiry_year,
                            }),
                        };
                    }
                }
                if ((builder.transactionType === src_1.TransactionType.Sale ||
                    builder.transactionType === src_1.TransactionType.Refund) &&
                    !builder.tagData) {
                    card.chip_condition = src_1.EnumMapping.mapEmvLastChipRead(gatewayProvider, builder.emvChipCondition);
                }
                if (builder.transactionType === src_1.TransactionType.Sale) {
                    card.funding =
                        builder.paymentMethod.paymentMethodType === src_1.PaymentMethodType.Debit
                            ? "DEBIT"
                            : "CREDIT";
                }
            }
        }
        else if (paymentMethod.isCardData) {
            card.number = paymentMethod.number;
            maskedValues = {
                ...maskedValues,
                ...src_1.ProtectSensitiveData.hideValue("payment_method.card.number", paymentMethod.number, 4, 6),
            };
            if (paymentMethod.expMonth) {
                card.expiry_month = paymentMethod.expMonth.toString().padStart(2, "0");
                maskedValues = {
                    ...maskedValues,
                    ...src_1.ProtectSensitiveData.hideValue("payment_method.card.expiry_month", card.expiry_month),
                };
            }
            if (paymentMethod.expYear) {
                card.expiry_year = paymentMethod.expYear
                    .toString()
                    .padStart(4, "0")
                    .substring(2, 4);
                maskedValues = {
                    ...maskedValues,
                    ...src_1.ProtectSensitiveData.hideValue("payment_method.card.expiry_year", card.expiry_year),
                };
            }
            if (paymentMethod.cvn) {
                card.cvv = paymentMethod.cvn;
                maskedValues = {
                    ...maskedValues,
                    ...src_1.ProtectSensitiveData.hideValue("payment_method.card.cvv", paymentMethod.cvn),
                };
                const cvnPresenceIndicator = paymentMethod.cvn
                    ? src_1.CvnPresenceIndicator.Present
                    : paymentMethod.cvnPresenceIndicator
                        ? paymentMethod.cvnPresenceIndicator
                        : "";
                card.cvv_indicator = CardUtils.getCvvIndicator(cvnPresenceIndicator);
            }
            if (builder.emvChipCondition && !builder.tagData) {
                card.chip_condition = src_1.EnumMapping.mapEmvLastChipRead(gatewayProvider, builder.emvChipCondition);
            }
        }
        if (paymentMethod.isPinProtected) {
            card.pin_block = paymentMethod.pinBlock;
        }
        const billingAddress = builder.billingAddress
            ? builder.billingAddress.streetAddress1
            : undefined;
        const postalCode = builder.billingAddress
            ? builder.billingAddress.postalCode
            : undefined;
        card.tag = builder.tagData;
        card.avs_address = billingAddress;
        card.avs_postal_code = postalCode;
        card.authcode = builder.offlineAuthCode;
        maskedValues;
        return card;
    }
    static getCvvIndicator(cvnPresenceIndicator) {
        let cvvIndicator;
        switch (cvnPresenceIndicator) {
            case 1:
                cvvIndicator = "PRESENT";
                break;
            case 2:
                cvvIndicator = "ILLEGIBLE";
                break;
            case 3:
                cvvIndicator = "NOT_ON_CARD";
                break;
            default:
                cvvIndicator = "NOT_PRESENT";
                break;
        }
        return cvvIndicator;
    }
    static parseTrackData(paymentMethod) {
        const trackData = paymentMethod.value;
        const trackTwoPattern = new RegExp(CardUtils.trackTwoPattern);
        const trackOnePattern = new RegExp(CardUtils.trackOnePattern);
        let matches;
        matches = trackTwoPattern.exec(trackData);
        if (matches && matches[1] && matches[2]) {
            const pan = matches[1];
            const expiry = matches[2];
            let discretionary = matches[3] || null;
            if (discretionary) {
                if ((pan + expiry + discretionary).length === 37 &&
                    discretionary.toLowerCase().endsWith("f")) {
                    discretionary = discretionary.substring(0, discretionary.length - 1);
                }
                paymentMethod.discretionaryData = discretionary;
            }
            paymentMethod.trackNumber = src_1.TrackNumber.TRACK_TWO;
            paymentMethod.pan = pan;
            paymentMethod.expiry = expiry;
            paymentMethod.trackData = `${pan}=${expiry}${discretionary}?`;
        }
        else {
            matches = trackOnePattern.exec(trackData);
            if (matches && matches[1] && matches[2]) {
                paymentMethod.trackNumber = src_1.TrackNumber.TRACK_ONE;
                paymentMethod.pan = matches[1];
                paymentMethod.expiry = matches[2];
                paymentMethod.trackData = matches[0].replace("%", "");
            }
        }
        return paymentMethod;
    }
    static getCardType(number) {
        number = number.replace(/[ -]/g, "");
        let rvalue = "Unknown";
        for (const [type, regex] of Object.entries(CardUtils.cardTypes)) {
            if (regex.test(number)) {
                rvalue = type;
            }
        }
        if (rvalue !== "Unknown") {
            if (CardUtils.isFleet(rvalue, number)) {
                rvalue += "Fleet";
            }
        }
        return rvalue;
    }
    static isFleet(cardType, pan) {
        if (pan !== "") {
            const compareValue = pan.substring(0, 6);
            const baseCardType = cardType.replace("Fleet", "");
            if (CardUtils.fleetBinMap[baseCardType]) {
                const binRanges = CardUtils.fleetBinMap[baseCardType];
                for (const [lowerRange, upperRange] of binRanges) {
                    if (compareValue >= lowerRange && compareValue <= upperRange) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
}
exports.CardUtils = CardUtils;
//# sourceMappingURL=CardUtils.js.map