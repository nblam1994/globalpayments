"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = void 0;
const fs = __importStar(require("fs"));
const fsPromises = __importStar(require("fs/promises"));
class Logger {
    static INFO_LOG_LEVEL = "info";
    logLevels = {
        info: "info",
        warn: "warn",
        error: "error",
        fatal: "fatal",
    };
    options = {
        extension: "txt",
        dateFormat: "Y-m-d G:i:s.u",
        filename: false,
        flushFrequency: false,
        prefix: "log_",
        logFormat: false,
        appendContext: true,
    };
    queue = new Map();
    logFilePath;
    logLineCount = 0;
    fileHandleSync;
    fileHandle;
    lastLine = "";
    constructor(logDirectory) {
        logDirectory = logDirectory.replace(/[\\\/]$/, ""); // rtrim
        if (!fs.existsSync(logDirectory)) {
            fs.mkdirSync(logDirectory, {
                recursive: true,
            });
        }
        this.setLogFilePath(logDirectory);
        if (fs.existsSync(this.logFilePath) && !fs.constants.W_OK) {
            throw new Error("The file could not be written to. Check that appropriate permissions have been set.");
        }
        this.setFileHandleSync("a");
        if (!this.fileHandleSync) {
            throw new Error("The file could not be opened. Check permissions.");
        }
        this.closeFileHandleSync();
    }
    setLogToStdOut(stdOutPath) {
        this.logFilePath = stdOutPath;
    }
    setLogFilePath(logDirectory) {
        if (this.options.filename) {
            const filename = this.options.filename;
            const extension = this.options.extension;
            if (filename.includes(".log") || filename.includes(".txt")) {
                this.logFilePath = `${logDirectory}/${filename}`;
            }
            else {
                this.logFilePath = `${logDirectory}/${filename}.${extension}`;
            }
        }
        else {
            const prefix = this.options.prefix;
            const dateObj = new Date();
            const date = `${dateObj.getFullYear()}-` +
                `${(dateObj.getMonth() + 1).toString().padStart(2, "0")}-` +
                `${dateObj.getUTCDate().toString().padStart(2, "0")}`;
            this.logFilePath = `${logDirectory}/${prefix}${date}.${this.options.extension}`;
        }
    }
    setFileHandleSync(writeMode) {
        this.fileHandleSync = fs.openSync(this.logFilePath, writeMode);
    }
    closeFileHandleSync() {
        fs.closeSync(this.fileHandleSync);
    }
    async setFileHandle(writeMode) {
        this.fileHandle = await fsPromises.open(this.logFilePath, writeMode);
    }
    async closeFileHandle() {
        await this.fileHandle.close();
    }
    setDateFormat(dateFormat) {
        this.options.dateFormat = dateFormat;
    }
    queueLog(level, requestId, message, context = {}) {
        const formattedMessage = this.formatMessage(level, message, context);
        this.pushToQueueLog(requestId, formattedMessage);
    }
    async log(requestId) {
        const queuedLogs = this.queue.get(requestId);
        if (queuedLogs) {
            await this.write(queuedLogs.join(""));
        }
    }
    pushToQueueLog(requestId, formattedMessage) {
        if (!this.queue.get(requestId)) {
            this.queue.set(requestId, [formattedMessage]);
            return;
        }
        this.queue.get(requestId)?.push(formattedMessage);
    }
    async write(message) {
        if (this.fileHandleSync !== null) {
            try {
                await this.setFileHandle("a");
                await fsPromises.appendFile(this.fileHandle, message);
                this.lastLine = message.trim();
                this.logLineCount++;
                if (this.options.flushFrequency &&
                    this.logLineCount % this.options.flushFrequency === 0) {
                    await this.fileHandle.datasync();
                }
                await this.closeFileHandle();
            }
            catch (error) {
                throw new Error("The file could not be written to. Check that appropriate permissions have been set.");
            }
        }
    }
    getLogFilePath() {
        return this.logFilePath;
    }
    getLastLogLine() {
        return this.lastLine;
    }
    formatMessage(level, message, context) {
        let formattedMessage;
        if (this.options.logFormat) {
            const parts = {
                date: this.getTimestamp(),
                level: String(level).toUpperCase(),
                "level-padding": " ".repeat(9 - String(level).length),
                priority: this.logLevels[level],
                message,
                context: JSON.stringify(context),
            };
            let formattedMessage = this.options.logFormat;
            for (const [part, value] of Object.entries(parts)) {
                formattedMessage = formattedMessage.replace(`{${part}}`, value);
            }
        }
        else {
            formattedMessage = `[${this.getTimestamp()}] [${level}] ${message}`;
        }
        if (this.options.appendContext && Object.keys(context).length > 0) {
            formattedMessage += `\n${this.indent(this.contextToString(context))}`;
        }
        return `${formattedMessage}\n`;
    }
    getTimestamp() {
        const dateObj = new Date();
        const month = (dateObj.getMonth() + 1).toString().padStart(2, "0");
        const day = dateObj.getUTCDate().toString().padStart(2, "0");
        const hour = (dateObj.getUTCHours() - dateObj.getTimezoneOffset() / 60)
            .toString()
            .padStart(2, "0");
        const minutes = dateObj.getUTCMinutes().toString().padStart(2, "0");
        const seconds = dateObj.getUTCSeconds().toString().padStart(2, "0");
        const date = `${dateObj.getFullYear()}-${month}-${day} ` +
            `${hour}:${minutes}:${seconds}`;
        return date;
    }
    contextToString(context) {
        let exportString = "";
        for (const [key, value] of Object.entries(context)) {
            exportString += `${key}: `;
            exportString += String(value)
                .replace(/=>\s+([a-zA-Z])/g, "=> $1")
                .replace(/array\(\s+\)/g, "array()")
                .replace(/^  |\G  /gm, "    ")
                .replace(/array \(/g, "array(");
            exportString += "\n";
        }
        return exportString.replace(/\\\\|\\'/g, "\\$1").replace(/\s+$/g, "");
    }
    indent(string, indent = "    ") {
        return indent + string.replace(/\n/g, `\n${indent}`);
    }
    async info(message, requestId, context = {}, queue) {
        this.queueLog("INFO_LOG_LEVEL", requestId, message, context);
        if (!queue) {
            await this.log(requestId);
        }
    }
}
exports.Logger = Logger;
//# sourceMappingURL=Logger.js.map