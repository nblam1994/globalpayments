"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StringUtils = void 0;
const src_1 = require("../../src");
class StringUtils {
    static leftPad(source, length, padString) {
        if (!source) {
            return source;
        }
        const pad = padString.repeat(length);
        return pad.substring(0, pad.length - source.length) + source;
    }
    static uuid() {
        //// return uuid of form xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
        let uuid = "";
        let ii;
        for (ii = 0; ii < 32; ii += 1) {
            switch (ii) {
                case 8:
                case 20:
                    uuid += "-";
                    uuid += ((Math.random() * 16) | 0).toString(16);
                    break;
                case 12:
                    uuid += "-";
                    uuid += "4";
                    break;
                case 16:
                    uuid += "-";
                    uuid += ((Math.random() * 4) | 8).toString(16);
                    break;
                default:
                    uuid += ((Math.random() * 16) | 0).toString(16);
            }
        }
        return uuid;
    }
    static btoa(t) {
        if (Buffer.from) {
            return Buffer.from(t, "ascii").toString("base64");
        }
        return new Buffer(t, "ascii").toString("base64");
    }
    static atob(t) {
        if (Buffer.from) {
            return Buffer.from(t, "base64").toString("ascii");
        }
        return new Buffer(t, "base64").toString("ascii");
    }
    /**
     * Strip all non-numeric characters
     *
     * @param value - The input string
     * @returns The string with non-numeric characters removed
     */
    static validateToNumber(value) {
        return value.replace(/[^0-9]/g, "");
    }
    static toAmount(str) {
        if (!str) {
            return "0";
        }
        return (parseFloat(str) / 100).toString();
    }
    static toNumeric(value) {
        if (value === null) {
            return "";
        }
        if (String(value) === "0") {
            return "000";
        }
        if (isNaN(parseFloat(value)) && !isFinite(parseFloat(value))) {
            throw new src_1.ArgumentError("A non well formed numeric value encountered!");
        }
        const f = parseFloat(value.toString()) * 100;
        if (0 < Number(value) && Number(value) < 1) {
            return "0" + parseFloat(f.toFixed(2)).toString();
        }
        return parseFloat(f.toFixed(2)).toString();
    }
    static boolToString(value) {
        if (typeof value !== "boolean") {
            return;
        }
        return JSON.stringify(value);
    }
    static isJson(string) {
        try {
            JSON.parse(string);
            return true;
        }
        catch (e) {
            return false;
        }
    }
}
exports.StringUtils = StringUtils;
//# sourceMappingURL=StringUtils.js.map