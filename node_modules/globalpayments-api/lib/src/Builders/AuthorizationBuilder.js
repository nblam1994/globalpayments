"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthorizationBuilder = void 0;
const __1 = require("../");
const TransactionBuilder_1 = require("./TransactionBuilder");
class AuthorizationBuilder extends TransactionBuilder_1.TransactionBuilder {
    alias;
    aliasAction;
    allowDuplicates;
    allowPartialAuth;
    amount;
    authAmount;
    amountEstimated;
    balanceInquiryType;
    billingAddress;
    cardBrandTransactionId;
    cashBackAmount;
    clientTransactionId;
    currency;
    customerData;
    customerId;
    customerIpAddress;
    cvn;
    description;
    dynamicDescriptor;
    ecommerceInfo;
    gratuity;
    convenienceAmt;
    shippingAmt;
    hostedPaymentData;
    invoiceNumber;
    level2Request;
    offlineAuthCode;
    oneTimePayment;
    orderId;
    paymentMethodUsageMode;
    homePhone;
    workPhone;
    shippingPhone;
    shippingAmount;
    orderDetails;
    productId;
    recurringSequence;
    recurringType;
    requestMultiUseToken;
    /**
     * Used in conjunction with requestMultiUseToken to request a unique token
     * For use with Portico Gateway only
     *
     * @internal
     * @var bool
     */
    requestUniqueToken;
    replacementCard;
    scheduleId;
    shippingAddress;
    timestamp;
    dccRateData;
    transactionInitiator;
    idempotencyKey;
    emvChipCondition;
    storedCredential;
    productData;
    merchantCategory;
    constructor(type, paymentMethod) {
        super(type, paymentMethod);
        if (paymentMethod) {
            this.paymentMethod = paymentMethod;
        }
    }
    /**
     * Executes the authorization builder against the gateway.
     *
     * @returns Promise<Transaction>
     */
    execute(configName = "default") {
        super.execute();
        return __1.ServicesContainer.instance()
            .getClient(configName)
            .processAuthorization(this);
    }
    /**
     * Serializes an authorization builder for hosted payment page requests.
     *
     * Requires the gateway and account support hosted payment pages.
     *
     * @throws UnsupportedTransactionError Thrown when gateway doesn't support hosted payments
     * @returns string
     */
    serialize() {
        this.transactionModifier = __1.TransactionModifier.HostedRequest;
        super.execute();
        const client = __1.ServicesContainer.instance().getClient();
        if (client.supportsHostedPayments) {
            return client.serializeRequest(this);
        }
        throw new __1.UnsupportedTransactionError("Your current gateway does not support hosted payments");
    }
    setupValidations() {
        this.validations
            .of("transactionType", 
        /* tslint:disable:trailing-comma */
        __1.TransactionType.Auth |
            __1.TransactionType.Sale |
            __1.TransactionType.Refund |
            __1.TransactionType.AddValue)
            .with("transactionModifier", __1.TransactionModifier.None)
            .check("amount")
            .isNotNull()
            .check("currency")
            .isNotNull()
            .check("paymentMethod")
            .isNotNull();
        this.validations
            .of("transactionType", 
        /* tslint:disable:trailing-comma */
        __1.TransactionType.Auth | __1.TransactionType.Sale | __1.TransactionType.Verify)
            .with("transactionModifier", __1.TransactionModifier.HostedRequest)
            .check("amount")
            .isNotNull()
            .check("currency")
            .isNotNull();
        this.validations
            .of("transactionType", 
        /* tslint:disable:trailing-comma */
        __1.TransactionType.Auth | __1.TransactionType.Sale)
            .with("transactionModifier", __1.TransactionModifier.Offline)
            .check("amount")
            .isNotNull()
            .check("currency")
            .isNotNull()
            .check("offlineAuthCode")
            .isNotNull()
            .check("offlineAuthCode")
            .isNotEmpty();
        this.validations
            .of("transactionType", __1.TransactionType.Auth | __1.TransactionType.Sale)
            .with("transactionModifier", __1.TransactionModifier.EncryptedMobile)
            .check("paymentMethod")
            .isNotNull()
            .check("paymentMethod")
            .isNotEmpty();
        this.validations
            .of("transactionType", __1.TransactionType.BenefitWithDrawal)
            .with("transactionModifier", __1.TransactionModifier.CashBack)
            .check("amount")
            .isNotNull()
            .check("currency")
            .isNotNull()
            .check("paymentMethod")
            .isNotNull();
        this.validations
            .of("transactionType", __1.TransactionType.Balance)
            .check("paymentMethod")
            .isNotNull();
        this.validations
            .of("transactionType", __1.TransactionType.Alias)
            .check("aliasAction")
            .isNotNull()
            .check("alias")
            .isNotNull();
        this.validations
            .of("transactionType", __1.TransactionType.Replace)
            .check("replacementCard")
            .isNotNull();
        this.validations
            .of("paymentMethodType", __1.PaymentMethodType.ACH)
            .check("billingAddress")
            .isNotNull();
        this.validations
            .of("transactionType", __1.TransactionType.Auth)
            .with("transactionModifier", __1.TransactionModifier.AlternativePaymentMethod)
            .check("amount")
            .isNotNull()
            .check("currency")
            .isNotNull()
            .check("paymentMethod")
            .isNotNull()
            .check("paymentMethod.returnUrl")
            .isNotNull()
            .check("paymentMethod.statusUpdateUrl")
            .isNotNull()
            .check("paymentMethod.country")
            .isNotNull()
            .check("paymentMethod.accountHolderName")
            .isNotNull();
        this.validations
            .of("transactionType", __1.TransactionType.Sale)
            .with("transactionModifier", __1.TransactionModifier.AlternativePaymentMethod)
            .check("amount")
            .isNotNull()
            .check("currency")
            .isNotNull()
            .check("paymentMethod")
            .isNotNull()
            .check("paymentMethod.returnUrl")
            .isNotNull()
            .check("paymentMethod.statusUpdateUrl")
            .isNotNull()
            .check("paymentMethod.country")
            .isNotNull()
            .check("paymentMethod.accountHolderName")
            .isNotNull();
    }
    /**
     * Sets an address value; where applicable.
     *
     * Currently supports billing and shipping addresses.
     *
     * @param address The desired address information
     * @param addressType The desired address type
     * @returns AuthorizationBuilder
     */
    withAddress(address, addressType = __1.AddressType.Billing) {
        if (address === undefined) {
            return this;
        }
        address.type = addressType;
        if (addressType === __1.AddressType.Billing) {
            this.billingAddress = address;
        }
        else {
            this.shippingAddress = address;
        }
        return this;
    }
    withAlias(aliasAction, alias) {
        if (alias !== undefined) {
            this.alias = alias;
        }
        this.aliasAction = aliasAction;
        return this;
    }
    /**
     * Allows duplicate transactions by skipping the
     * gateway's duplicate checking.
     *
     * @param allowDuplicates The duplicate skip flag
     * @returns AuthorizationBuilder
     */
    withAllowDuplicates(allowDuplicates) {
        if (allowDuplicates !== undefined) {
            this.allowDuplicates = allowDuplicates;
        }
        return this;
    }
    /**
     * Allows partial authorizations to occur.
     *
     *
     * @param allowPartialAuth The allow partial flag
     * @returns AuthorizationBuilder
     */
    withAllowPartialAuth(allowPartialAuth) {
        if (allowPartialAuth !== undefined) {
            this.allowPartialAuth = allowPartialAuth;
        }
        return this;
    }
    /**
     * Sets the transaction's amount
     *
     * @param amount The amount
     * @returns AuthorizationBuilder
     */
    withAmount(amount) {
        if (amount !== undefined) {
            this.amount = amount;
        }
        return this;
    }
    /**
     * Sets the transaction's authorization amount; where applicable.
     *
     * This is a specialized field. In most cases,
     * `Authorization.withAmount` should be used.
     *
     * @param authAmount The authorization amount
     * @returns AuthorizationBuilder
     */
    withAuthAmount(authAmount) {
        if (authAmount !== undefined) {
            this.authAmount = authAmount;
        }
        return this;
    }
    withBalanceInquiryType(inquiry) {
        if (inquiry !== undefined) {
            this.balanceInquiryType = inquiry;
        }
        return this;
    }
    /**
     * Sets Credential on File fields
     */
    withCardBrandStorage(transactionInitiator, value) {
        this.transactionInitiator = transactionInitiator;
        if (value !== undefined) {
            this.cardBrandTransactionId = value;
        }
        return this;
    }
    /**
     * Sets the cash back amount.
     *
     * This is a specialized field for debit or EBT transactions.
     *
     * @param amount The desired cash back amount
     * @returns AuthorizationBuilder
     */
    withCashBack(amount) {
        if (amount !== undefined) {
            this.cashBackAmount = amount;
            this.transactionModifier = __1.TransactionModifier.CashBack;
        }
        return this;
    }
    /**
     * Sets the client transaction ID.
     *
     * This is an application derived value that can be used to identify a
     * transaction in case a gateway transaction ID is not returned, e.g.
     * in cases of timeouts.
     *
     * The supplied value should be unique to the configured merchant or
     * terminal account.
     *
     * @param clientTransactionId The client transaction ID
     * @returns AuthorizationBuilder
     */
    withClientTransactionId(clientTransactionId) {
        if (clientTransactionId === undefined) {
            return this;
        }
        if (this.transactionType !== __1.TransactionType.Reversal &&
            this.transactionType !== __1.TransactionType.Refund) {
            this.clientTransactionId = clientTransactionId;
            return this;
        }
        if (!(this.paymentMethod instanceof __1.TransactionReference)) {
            this.paymentMethod =
                new __1.TransactionReference();
        }
        this.paymentMethod.clientTransactionId = clientTransactionId;
        return this;
    }
    /**
     * Sets the transaction's currency; where applicable.
     *
     * The formatting for the supplied value will currently depend on
     * the configured gateway's requirements.
     *
     * @param currency The currency
     * @returns AuthorizationBuilder
     */
    withCurrency(currency) {
        if (currency !== undefined) {
            this.currency = currency;
        }
        return this;
    }
    /**
     * Sets the transaction's currency; where applicable.
     *
     * The formatting for the supplied value will currently depend on
     * the configured gateway's requirements.
     *
     * @param currency The currency
     * @returns AuthorizationBuilder
     */
    withCustomerData(customerData) {
        if (customerData !== undefined) {
            this.customerData = customerData;
        }
        return this;
    }
    /**
     * Sets the customer ID; where applicable.
     *
     * This is an application/merchant generated value.
     *
     * @param customerId The customer ID
     * @returns AuthorizationBuilder
     */
    withCustomerId(customerId) {
        if (customerId !== undefined) {
            this.customerId = customerId;
        }
        return this;
    }
    /**
     * Sets the customer's IP address; where applicable.
     *
     * This value should be obtained during the payment process.
     *
     * @param customerIpAddress The customer's IP address
     * @returns AuthorizationBuilder
     */
    withCustomerIpAddress(customerIpAddress) {
        if (customerIpAddress !== undefined) {
            this.customerIpAddress = customerIpAddress;
        }
        return this;
    }
    /**
     * Sets the CVN value for recurring payments; where applicable.
     *
     * @param cvn CVN value to use in the request
     * @returns AuthorizationBuilder
     */
    withCvn(cvn) {
        if (cvn !== undefined) {
            this.cvn = cvn;
        }
        return this;
    }
    /**
     * Sets the transaction's description.
     *
     * This value is not guaranteed to be sent in the authorization
     * or settlement process.
     *
     * @param description The description
     * @returns AuthorizationBuilder
     */
    withDescription(description) {
        if (description !== undefined) {
            this.description = description;
        }
        return this;
    }
    /**
     * Sets the transaction's dynamic descriptor.
     *
     * This value is sent during the authorization process and is displayed
     * in the consumer's account.
     *
     * @param dynamicDescriptor The dynamic descriptor
     * @returns AuthorizationBuilder
     */
    withDynamicDescriptor(dynamicDescriptor) {
        if (dynamicDescriptor !== undefined) {
            this.dynamicDescriptor = dynamicDescriptor;
        }
        return this;
    }
    /**
     * Sets eCommerce specific data; where applicable.
     *
     * This can include:
     *
     *   - Consumer authentication (3DSecure) data
     *   - Direct market data
     *
     * @param ecommerceInfo The eCommerce data
     * @returns AuthorizationBuilder
     */
    withEcommerceInfo(ecommerceInfo) {
        if (ecommerceInfo !== undefined) {
            this.ecommerceInfo = ecommerceInfo;
        }
        return this;
    }
    /**
     * Sets the gratuity amount; where applicable.
     *
     * This value is information only and does not affect
     * the authorization amount.
     *
     * @param gratuity The gratuity amount
     * @returns AuthorizationBuilder
     */
    withGratuity(gratuity) {
        if (gratuity !== undefined) {
            this.gratuity = gratuity;
        }
        return this;
    }
    /**
     * Sets the Convenience amount; where applicable.
     *
     * @param convenienceAmt The Convenience amount
     * @returns AuthorizationBuilder
     */
    withConvenienceAmt(convenienceAmt) {
        if (convenienceAmt !== undefined) {
            this.convenienceAmt = convenienceAmt;
        }
        return this;
    }
    /**
     * Sets the Shipping amount; where applicable.
     *
     * @param shippingAmt The Shipping amount
     * @returns AuthorizationBuilder
     */
    withShippingAmt(shippingAmt) {
        if (shippingAmt !== undefined) {
            this.shippingAmt = shippingAmt;
        }
        return this;
    }
    /**
     * Additional hosted payment specific information for Realex HPP implementation.
     *
     * @param hostedPaymentData The hosted payment data
     * @returns AuthorizationBuilder
     */
    withHostedPaymentData(hostedPaymentData) {
        const client = __1.ServicesContainer.instance().getClient();
        if (!client.supportsHostedPayments) {
            throw new __1.UnsupportedTransactionError("Your current gateway does not support hosted payments.");
        }
        if (hostedPaymentData !== undefined) {
            this.hostedPaymentData = hostedPaymentData;
        }
        return this;
    }
    /**
     * Sets the invoice number; where applicable.
     *
     * @param invoiceNumber The invoice number
     * @returns AuthorizationBuilder
     */
    withInvoiceNumber(invoiceNumber) {
        if (invoiceNumber !== undefined) {
            this.invoiceNumber = invoiceNumber;
        }
        return this;
    }
    /**
     * Sets the commercial request flag; where applicable.
     *
     * This flag indicates commercial purchase cards are accepted/expected.
     * The application should inspect the transaction response and pass the
     * appropriate Level II data when necessary.
     *
     * @param level2Request The commercial request flag
     * @returns AuthorizationBuilder
     */
    withCommercialRequest(level2Request) {
        if (level2Request !== undefined) {
            this.level2Request = level2Request;
        }
        return this;
    }
    /**
     * Sets the offline authorization code; where applicable.
     *
     * The merchant is required to supply this value as obtained when
     * calling the issuing bank for the authorization.
     *
     * @param offlineAuthCode The offline authorization code
     * @returns AuthorizationBuilder
     */
    withOfflineAuthCode(offlineAuthCode) {
        if (offlineAuthCode !== undefined) {
            this.offlineAuthCode = offlineAuthCode;
            this.transactionModifier = __1.TransactionModifier.Offline;
        }
        return this;
    }
    /**
     * Sets the one-time payment flag; where applicable.
     *
     * This is only useful when using recurring payment profiles for
     * one-time payments that are not a part of a recurring schedule.
     *
     * @param oneTimePayment The one-time flag
     * @returns AuthorizationBuilder
     */
    withOneTimePayment(oneTimePayment) {
        if (oneTimePayment !== undefined) {
            this.oneTimePayment = oneTimePayment;
            this.transactionModifier = __1.TransactionModifier.Recurring;
        }
        return this;
    }
    /**
     * Sets the transaction's order ID; where applicable.
     *
     * @param orderId The order ID
     * @returns AuthorizationBuilder
     */
    withOrderId(orderId) {
        if (orderId !== undefined) {
            this.orderId = orderId;
        }
        return this;
    }
    withShippingAmount(shippingAmount) {
        this.shippingAmount = shippingAmount;
        return this;
    }
    withOrderDetails(orderDetails) {
        this.orderDetails = orderDetails;
        return this;
    }
    /**
     * Sets the transaction's product ID; where applicable.
     *
     * @param productId The product ID
     * @returns AuthorizationBuilder
     */
    withProductId(productId) {
        if (productId !== undefined) {
            this.productId = productId;
        }
        return this;
    }
    /**
     * Sets the Recurring Info for Realex based recurring payments;
     * where applicable.
     *
     * @param type The value can be 'fixed' or 'variable' depending on whether
     *             the amount will change for each transaction.
     * @param sequence  Indicates where in the recurring sequence the transaction
     *                  occurs. Must be 'first' for the first transaction for this
     *                  card, 'subsequent' for transactions after that, and 'last'
     *                  for the final transaction of the set.
     * @returns AuthorizationBuilder
     */
    withRecurringInfo(type, sequence) {
        if (type !== undefined) {
            this.recurringType = type;
        }
        if (sequence !== undefined) {
            this.recurringSequence = sequence;
        }
        return this;
    }
    /**
     * Requests multi-use tokenization / card storage.
     *
     * This will depend on a successful transaction. If there was a failure
     * or decline, the multi-use tokenization / card storage will not be
     * successful.
     *
     * @param requestMultiUseToken The request flag
     * @returns AuthorizationBuilder
     */
    withRequestMultiUseToken(requestMultiUseToken, requestUniqueToken = false) {
        if (requestMultiUseToken !== undefined) {
            this.requestMultiUseToken = requestMultiUseToken;
        }
        this.requestUniqueToken = requestUniqueToken;
        return this;
    }
    withPaymentMethodUsageMode(paymentMethodUsageMode) {
        this.paymentMethodUsageMode = paymentMethodUsageMode;
        return this;
    }
    withReplacementCard(replacementCard) {
        if (replacementCard !== undefined) {
            this.replacementCard = replacementCard;
        }
        return this;
    }
    /**
     * Sets the schedule ID associated with the transaction; where applicable.
     *
     * This is specific to transactions against recurring profiles that are
     * a part of a recurring schedule.
     *
     * @param scheduleId The schedule ID
     * @returns AuthorizationBuilder
     */
    withScheduleId(scheduleId) {
        if (scheduleId !== undefined) {
            this.scheduleId = scheduleId;
        }
        return this;
    }
    /**
     * Sets the related gateway transaction ID; where applicable.
     *
     * This value is used to associated a previous transaction with the
     * current transaction.
     *
     * @param transactionId The gateway transaction ID
     * @returns AuthorizationBuilder
     */
    withTransactionId(transactionId) {
        if (transactionId === undefined) {
            return this;
        }
        if (this.paymentMethod instanceof __1.TransactionReference) {
            this.paymentMethod.transactionId = transactionId;
            return this;
        }
        return this.withPaymentMethod(new __1.TransactionReference(transactionId));
    }
    withTimestamp(timestamp) {
        if (timestamp !== undefined) {
            this.timestamp = timestamp;
        }
        return this;
    }
    withPaymentMethod(paymentMethod) {
        if (paymentMethod !== undefined) {
            this.paymentMethod = paymentMethod;
        }
        if (this.paymentMethod instanceof __1.EBTCardData &&
            this.paymentMethod.serialNumber !== null) {
            this.transactionModifier = __1.TransactionModifier.Voucher;
        }
        return this;
    }
    withProductData(productData) {
        this.productData = productData;
        return this;
    }
    withPhoneNumber(phoneCountryCode, value, phoneNumberType) {
        const phoneNumber = new __1.PhoneNumber(phoneCountryCode, value, phoneNumberType);
        switch (phoneNumberType) {
            case __1.PhoneNumberType.HOME:
                this.homePhone = phoneNumber;
                break;
            case __1.PhoneNumberType.WORK:
                this.workPhone = phoneNumber;
                break;
            case __1.PhoneNumberType.SHIPPING:
                this.shippingPhone = phoneNumber;
                break;
        }
        return this;
    }
    withIdempotencyKey(idempotencyKey) {
        if (idempotencyKey !== undefined) {
            this.idempotencyKey = idempotencyKey;
        }
        return this;
    }
    withMultiCapture(multiCapture = false) {
        this.multiCapture = multiCapture;
        return this;
    }
    withStoredCredentials(storedCredential) {
        this.storedCredential = storedCredential;
        return this;
    }
    withChipCondition(value) {
        this.emvChipCondition = value;
        return this;
    }
    withTagData(value) {
        this.tagData = value;
        return this;
    }
    withAmountEstimated(value) {
        this.amountEstimated = value;
        return this;
    }
    withMerchantCategory(merchantCategory) {
        this.merchantCategory = merchantCategory;
        return this;
    }
    /**
     * Set the request dccRateData
     *
     * @param DccRateData dccRateData
     *
     * @return AuthorizationBuilder
     */
    withDccRateData(value) {
        this.dccRateData = value;
        return this;
    }
}
exports.AuthorizationBuilder = AuthorizationBuilder;
//# sourceMappingURL=AuthorizationBuilder.js.map