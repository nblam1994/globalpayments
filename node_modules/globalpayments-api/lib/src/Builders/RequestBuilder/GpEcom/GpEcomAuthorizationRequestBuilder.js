"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GpEcomAuthorizationRequestBuilder = void 0;
const src_1 = require("../../../../src");
const GpEcomRequestBuilder_1 = require("./GpEcomRequestBuilder");
const elementtree_1 = require("@azz/elementtree");
class GpEcomAuthorizationRequestBuilder extends GpEcomRequestBuilder_1.GpEcomRequestBuilder {
    maskedValues = {};
    /***
     * @param AuthorizationBuilder builder
     *
     * @return bool
     */
    canProcess(builder) {
        if (builder instanceof src_1.AuthorizationBuilder) {
            return true;
        }
        return false;
    }
    buildRequestFromJson(jsonRequest, config) {
        jsonRequest;
        config;
        // do nothing currently
    }
    /**
     * @param BaseBuilder builder
     * @param GpEcomConfig config
     * @return Request
     */
    buildRequest(builder, config) {
        if (!builder.transactionModifier &&
            builder.transactionModifier === src_1.TransactionModifier.EncryptedMobile &&
            builder.paymentMethod.mobileType === src_1.EncyptedMobileType.GooglePay &&
            (!builder.amount || !builder.currency)) {
            throw new Error("Amount and Currency cannot be null for google payment");
        }
        const timestamp = builder.timestamp || src_1.GenerationUtils.generateTimestamp();
        const orderId = builder.orderId || src_1.GenerationUtils.generateOrderId();
        const transactionType = src_1.GpEcomMapping.mapAuthRequestType(builder);
        const request = (0, elementtree_1.Element)("request", {
            timestamp,
            type: transactionType,
        });
        if (config.merchantId) {
            (0, elementtree_1.SubElement)(request, "merchantid").append((0, elementtree_1.CData)(config.merchantId));
        }
        if (config.accountId !== null) {
            (0, elementtree_1.SubElement)(request, "account").append((0, elementtree_1.CData)(config.accountId));
        }
        if (config.channel) {
            (0, elementtree_1.SubElement)(request, "channel").append((0, elementtree_1.CData)(config.channel));
        }
        if (builder.amount) {
            const amountAttrs = builder.currency
                ? { currency: builder.currency }
                : {};
            (0, elementtree_1.SubElement)(request, "amount", amountAttrs).append((0, elementtree_1.CData)(this.numberFormat(builder.amount)));
        }
        // refund hash
        if (builder.transactionType === src_1.TransactionType.Refund) {
            (0, elementtree_1.SubElement)(request, "refundhash").append((0, elementtree_1.CData)(src_1.GenerationUtils.generateHash(config.refundPassword) || ""));
        }
        // this needs to be figured out based on txn type and set to 0, 1 or MULTI
        if (builder.transactionType === src_1.TransactionType.Sale ||
            builder.transactionType === src_1.TransactionType.Auth) {
            const autoSettle = builder.transactionType === src_1.TransactionType.Sale ? "1" : "0";
            (0, elementtree_1.SubElement)(request, "autosettle", { flag: autoSettle });
        }
        (0, elementtree_1.SubElement)(request, "orderid").append((0, elementtree_1.CData)(orderId));
        if (builder.paymentMethod instanceof src_1.CreditCardData) {
            const card = builder.paymentMethod;
            if (builder.transactionModifier === src_1.TransactionModifier.EncryptedMobile) {
                (0, elementtree_1.SubElement)(request, "token").append((0, elementtree_1.CData)(card.token));
                (0, elementtree_1.SubElement)(request, "mobile").append((0, elementtree_1.CData)(card.mobileType));
            }
            else {
                const cardElement = (0, elementtree_1.SubElement)(request, "card");
                (0, elementtree_1.SubElement)(cardElement, "number").append((0, elementtree_1.CData)(card.number));
                const date = src_1.StringUtils.leftPad(card.expMonth, 2, "0") +
                    src_1.StringUtils.leftPad((card.expYear || "").substr(2, 2), 2, "0");
                (0, elementtree_1.SubElement)(cardElement, "expdate").append((0, elementtree_1.CData)(date));
                (0, elementtree_1.SubElement)(cardElement, "chname").append((0, elementtree_1.CData)(card.cardHolderName));
                this.maskedValues = {
                    ...this.maskedValues,
                    ...src_1.ProtectSensitiveData.hideValue("card.expdate", card.getShortExpiry() || ""),
                };
                (0, elementtree_1.SubElement)(cardElement, "type").append((0, elementtree_1.CData)(card.getCardType().toUpperCase()));
                if (card.number) {
                    this.maskedValues = {
                        ...this.maskedValues,
                        ...src_1.ProtectSensitiveData.hideValue("card.number", card.number, 4, 6),
                    };
                }
                if (card.cvn) {
                    const cvnElement = (0, elementtree_1.SubElement)(cardElement, "cvn");
                    (0, elementtree_1.SubElement)(cvnElement, "number").append((0, elementtree_1.CData)(card.cvn));
                    (0, elementtree_1.SubElement)(cvnElement, "presind").append((0, elementtree_1.CData)(card.cvnPresenceIndicator.toString()));
                    this.maskedValues = {
                        ...this.maskedValues,
                        ...src_1.ProtectSensitiveData.hideValue("card.cvn.number", card.cvn || ""),
                    };
                }
                // issueno
            }
            const isVerify = builder.transactionType === src_1.TransactionType.Verify;
            (0, elementtree_1.SubElement)(request, "sha1hash").append((0, elementtree_1.CData)(this.generateHash(config, timestamp, orderId, builder.amount ? this.numberFormat(builder.amount) : "", builder.currency, builder.transactionModifier === src_1.TransactionModifier.EncryptedMobile
                ? card.token
                : card.number, isVerify)));
        }
        if ((builder.transactionType === src_1.TransactionType.Auth ||
            builder.transactionType === src_1.TransactionType.Capture ||
            builder.transactionType === src_1.TransactionType.Refund) &&
            builder.dynamicDescriptor) {
            const narrative = (0, elementtree_1.SubElement)(request, "narrative");
            (0, elementtree_1.SubElement)(narrative, "chargedescription").append((0, elementtree_1.CData)(builder.dynamicDescriptor.toUpperCase()));
        }
        if (Object.keys(builder.supplementaryData).length) {
            this.buildSupplementaryData(builder.supplementaryData, request);
        }
        src_1.Request.maskedValues = this.maskedValues;
        return new src_1.Request(config.serviceUrl, "POST", this.buildEnvelope(request));
    }
}
exports.GpEcomAuthorizationRequestBuilder = GpEcomAuthorizationRequestBuilder;
//# sourceMappingURL=GpEcomAuthorizationRequestBuilder.js.map