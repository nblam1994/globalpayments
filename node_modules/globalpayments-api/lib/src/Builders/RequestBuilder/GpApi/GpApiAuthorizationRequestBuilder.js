"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GpApiAuthorizationRequestBuilder = void 0;
const DTO_1 = require("../../../Entities/GpApi/DTO");
const src_1 = require("../../../../src");
class GpApiAuthorizationRequestBuilder {
    builder;
    maskedValues = {};
    /***
     * @param AuthorizationBuilder builder
     *
     * @return bool
     */
    canProcess(builder) {
        if (builder instanceof src_1.AuthorizationBuilder) {
            return true;
        }
        return false;
    }
    /**
     * @param BaseBuilder builder
     * @param GpApiConfig config
     * @return GpApiRequest|string
     */
    buildRequest(builder, config) {
        this.builder = builder;
        let requestData = null;
        let endpoint;
        const verb = "POST";
        switch (builder.transactionType) {
            case src_1.TransactionType.Sale:
            case src_1.TransactionType.Refund:
            case src_1.TransactionType.Auth:
                endpoint = src_1.GpApiRequest.TRANSACTION_ENDPOINT;
                requestData = this.createFromAuthorizationBuilder(builder, config);
                break;
            case src_1.TransactionType.Verify:
                if (builder.requestMultiUseToken && !builder.paymentMethod.token) {
                    endpoint = src_1.GpApiRequest.PAYMENT_METHODS_ENDPOINT;
                    /* eslint-disable indent */
                    const expiry_year = builder.paymentMethod.expYear
                        ? builder.paymentMethod.expYear
                            .toString()
                            .padStart(4, "0")
                            .substring(2, 4)
                        : undefined;
                    /* eslint-enable indent */
                    requestData = {
                        account_name: config.accessTokenInfo.tokenizationAccountName,
                        account_id: config.accessTokenInfo.tokenizationAccountID,
                        name: builder.description || undefined,
                        reference: builder.clientTransactionId
                            ? builder.clientTransactionId
                            : src_1.GenerationUtils.generateOrderId(),
                        usage_mode: builder.paymentMethodUsageMode || undefined,
                        fingerprint_mode: builder.customerData && builder.customerData.deviceFingerPrint
                            ? builder.customerData.deviceFingerPrint
                            : undefined,
                        card: {
                            number: builder.paymentMethod.number,
                            expiry_month: builder.paymentMethod.expMonth,
                            expiry_year,
                            cvv: builder.paymentMethod.cvn,
                        },
                    };
                    this.maskedValues = {
                        ...this.maskedValues,
                        ...src_1.ProtectSensitiveData.hideValues({
                            "card.expiry_month": requestData.card.expiry_month,
                            "card.expiry_year": requestData.card.expiry_year,
                            "card.cvv": requestData.card.cvv,
                        }),
                    };
                    this.maskedValues = {
                        ...this.maskedValues,
                        ...src_1.ProtectSensitiveData.hideValue("card.number", requestData.card.number, 4, 6),
                    };
                }
                else {
                    endpoint = src_1.GpApiRequest.VERIFICATIONS_ENDPOINT;
                    requestData = this.generateVerificationRequest(builder, config);
                }
                break;
            case src_1.TransactionType.DccRateLookup:
                endpoint = src_1.GpApiRequest.DCC_ENDPOINT;
                requestData = {
                    account_name: config.accessTokenInfo.transactionProcessingAccountName,
                    account_id: config.accessTokenInfo.transactionProcessingAccountID,
                    channel: config.channel,
                    amount: src_1.StringUtils.toNumeric(builder.amount || null),
                    currency: builder.currency,
                    country: config.country,
                    reference: builder.clientTransactionId || src_1.GenerationUtils.getGuuid(),
                    payment_method: this.createPaymentMethodParam(builder, config),
                };
                break;
            default:
                throw new Error("Unsupported transaction type");
        }
        src_1.GpApiRequest.maskedValues = this.maskedValues;
        return new src_1.GpApiRequest(endpoint, verb, JSON.stringify(requestData));
    }
    generateVerificationRequest(builder, config) {
        const requestBody = {
            account_name: config.accessTokenInfo.transactionProcessingAccountName,
            account_id: config.accessTokenInfo.transactionProcessingAccountID,
            channel: config.channel,
            reference: builder.clientTransactionId || src_1.GenerationUtils.getGuuid(),
            currency: builder.currency,
            country: config.country,
            payment_method: this.createPaymentMethodParam(builder, config),
        };
        if (builder.storedCredential) {
            this.setRequestStoredCredentials(builder.storedCredential, requestBody);
        }
        return requestBody;
    }
    createPaymentMethodParam(builder, config) {
        const paymentMethodContainer = builder.paymentMethod;
        const paymentMethod = new src_1.PaymentMethod();
        paymentMethod.entry_mode = this.getEntryMode(builder, config.channel);
        paymentMethod.name =
            paymentMethodContainer instanceof src_1.AlternativePaymentMethod
                ? paymentMethodContainer.accountHolderName
                : paymentMethodContainer.cardHolderName
                    ? paymentMethodContainer.cardHolderName
                    : undefined;
        paymentMethod.narrative = builder.dynamicDescriptor
            ? builder.dynamicDescriptor
            : undefined;
        switch (true) {
            case paymentMethodContainer instanceof src_1.CreditCardData:
                paymentMethod.fingerprint_mode =
                    builder.customerData && builder.customerData.deviceFingerPrint
                        ? builder.customerData.deviceFingerPrint
                        : undefined;
                const secureEcom = paymentMethodContainer.threeDSecure;
                if (secureEcom) {
                    paymentMethod.authentication = {
                        id: secureEcom.serverTransactionId,
                        three_ds: {
                            exempt_status: secureEcom.exemptStatus,
                            message_version: secureEcom.messageVersion,
                            eci: secureEcom.eci,
                            server_trans_reference: secureEcom.serverTransactionId,
                            ds_trans_reference: secureEcom.directoryServerTransactionId,
                            value: secureEcom.authenticationValue,
                        },
                    };
                }
                break;
            case paymentMethodContainer instanceof src_1.ECheck:
                paymentMethod.name = paymentMethodContainer.checkHolderName;
                paymentMethod.narrative = paymentMethodContainer.merchantNotes;
                paymentMethod.bank_transfer = {
                    account_number: paymentMethodContainer.accountNumber,
                    account_type: src_1.EnumMapping.mapAccountType(src_1.GatewayProvider.GpApi, paymentMethodContainer.accountType),
                    check_reference: paymentMethodContainer.checkReference,
                    sec_code: paymentMethodContainer.secCode,
                    bank: {
                        code: paymentMethodContainer.routingNumber,
                        name: paymentMethodContainer.bankName,
                        address: {
                            line_1: paymentMethodContainer.bankAddress?.streetAddress1 || null,
                            line_2: paymentMethodContainer.bankAddress?.streetAddress2 || null,
                            line_3: paymentMethodContainer.bankAddress?.streetAddress3 || null,
                            city: paymentMethodContainer.bankAddress?.city || null,
                            postal_code: paymentMethodContainer.bankAddress?.postalCode || null,
                            state: paymentMethodContainer.bankAddress?.state || null,
                            country: paymentMethodContainer.bankAddress?.countryCode || null,
                        },
                    },
                };
                this.maskedValues = {
                    ...this.maskedValues,
                    ...src_1.ProtectSensitiveData.hideValues({
                        "payment_method.bank_transfer.account_number": paymentMethodContainer.accountNumber,
                        "payment_method.bank_transfer.bank.code": paymentMethodContainer.routingNumber,
                    }, 4),
                };
                return paymentMethod;
            case paymentMethodContainer instanceof src_1.AlternativePaymentMethod:
                paymentMethod.apm = {
                    provider: paymentMethodContainer.alternativePaymentMethodType,
                    address_override_mode: paymentMethodContainer.addressOverrideMode
                        ? paymentMethodContainer.addressOverrideMode
                        : undefined,
                };
                return paymentMethod;
            default:
                break;
        }
        if (![
            src_1.TransactionModifier.EncryptedMobile,
            src_1.TransactionModifier.DecryptedMobile,
        ].includes(builder.transactionModifier)) {
            if (paymentMethodContainer instanceof src_1.CreditCardData &&
                paymentMethodContainer.token) {
                paymentMethod.id = paymentMethodContainer.token;
            }
            if (!paymentMethod.id) {
                paymentMethod.card = src_1.CardUtils.generateCard(builder, src_1.GatewayProvider.GpApi, this.maskedValues);
            }
        }
        else {
            /* digital wallet */
            let digitalWallet;
            switch (builder.transactionModifier) {
                case src_1.TransactionModifier.EncryptedMobile:
                    let paymentToken = null;
                    switch (paymentMethodContainer.mobileType) {
                        case src_1.EncyptedMobileType.ClickToPay:
                            paymentToken = { data: paymentMethodContainer.token };
                            break;
                        default:
                            paymentToken =
                                (paymentMethodContainer.token &&
                                    JSON.parse(paymentMethodContainer.token.replace(/(\\)(\w)/g, "$1$1$2"))) ||
                                    "";
                    }
                    digitalWallet.payment_token = paymentToken;
                    break;
                default:
                    break;
            }
            digitalWallet.provider = src_1.EnumMapping.mapDigitalWalletType(src_1.GatewayProvider.GpApi, paymentMethodContainer.mobileType);
            paymentMethod.digital_wallet = digitalWallet;
        }
        if (builder.cardBrandTransactionId) {
            if (!(paymentMethod.card instanceof DTO_1.Card)) {
                paymentMethod.card = new DTO_1.Card();
            }
            paymentMethod.card.brand_reference = builder.cardBrandTransactionId;
        }
        paymentMethod.storage_mode = builder.requestMultiUseToken
            ? "ON_SUCCESS"
            : undefined;
        return paymentMethod;
    }
    createFromAuthorizationBuilder(builder, config) {
        const captureMode = this.getCaptureMode(builder);
        let requestBody = {
            account_name: config.accessTokenInfo.transactionProcessingAccountName,
            account_id: config.accessTokenInfo.transactionProcessingAccountID,
            channel: config.channel,
            country: config.country,
            type: builder.transactionType === src_1.TransactionType.Refund
                ? src_1.PaymentType.REFUND
                : src_1.PaymentType.SALE,
            capture_mode: captureMode ? captureMode : src_1.CaptureMode.AUTO,
            authorization_mode: builder.allowPartialAuth ? "PARTIAL" : undefined,
            amount: src_1.StringUtils.toNumeric(builder.amount.toString()),
            currency: builder.currency,
            reference: builder.clientTransactionId
                ? builder.clientTransactionId
                : src_1.GenerationUtils.getGuuid(),
        };
        if (builder.paymentMethod instanceof src_1.Credit &&
            builder.paymentMethod.mobileType === src_1.EncyptedMobileType.ClickToPay) {
            requestBody.masked = builder.maskedDataResponse === true ? "YES" : "NO";
        }
        requestBody.description = builder.description || undefined;
        requestBody.order = builder.orderId
            ? { reference: builder.orderId }
            : undefined;
        requestBody.gratuity_amount = builder.gratuity
            ? src_1.StringUtils.toNumeric(builder.gratuity.toString())
            : undefined;
        requestBody.surcharge_amount = builder.surchargeAmount
            ? src_1.StringUtils.toNumeric(builder.surchargeAmount)
            : undefined;
        requestBody.convenience_amount = builder.convenienceAmount
            ? src_1.StringUtils.toNumeric(builder.convenienceAmount)
            : undefined;
        requestBody.cashback_amount = builder.cashBackAmount
            ? src_1.StringUtils.toNumeric(builder.cashBackAmount.toString())
            : undefined;
        requestBody.ip_address = builder.customerIpAddress;
        requestBody.merchant_category = builder.merchantCategory || undefined;
        requestBody.payment_method = this.createPaymentMethodParam(builder, config);
        if (builder.fraudFilter) {
            requestBody.risk_assessment = [this.mapFraudManagement()];
        }
        if (builder.paymentLinkId) {
            requestBody.link = { id: builder.paymentLinkId };
        }
        if (builder.paymentMethod instanceof src_1.ECheck ||
            builder.paymentMethod instanceof src_1.AlternativePaymentMethod) {
            requestBody.payer = this.setPayerInformation(builder);
        }
        if (builder.paymentMethod instanceof src_1.AlternativePaymentMethod) {
            const mappedOrder = this.setOrderInformation(builder, requestBody);
            requestBody = {
                ...requestBody,
                order: mappedOrder,
                ...this.setNotificationUrls(),
                amount: mappedOrder?.amount ||
                    src_1.StringUtils.toNumeric(builder.amount.toString()),
            };
        }
        if (builder.dccRateData) {
            requestBody.currency_conversion = { id: builder.dccRateData.dccId };
        }
        if (builder.storedCredential) {
            this.setRequestStoredCredentials(builder.storedCredential, requestBody);
        }
        return requestBody;
    }
    setNotificationUrls() {
        return {
            notifications: {
                return_url: this.builder.paymentMethod.returnUrl || undefined,
                status_url: this.builder.paymentMethod.statusUpdateUrl || undefined,
                cancel_url: this.builder.paymentMethod.cancelUrl || undefined,
            },
        };
    }
    setOrderInformation(builder, request) {
        let order = {};
        if (builder.orderDetails) {
            order = {
                description: builder.orderDetails.description,
            };
        }
        if (builder.shippingAddress) {
            order = {
                ...order,
                shipping_address: {
                    line_1: builder.shippingAddress.streetAddress1,
                    line_2: builder.shippingAddress.streetAddress2,
                    line_3: builder.shippingAddress.streetAddress3,
                    city: builder.shippingAddress.city,
                    postal_code: builder.shippingAddress.postalCode,
                    state: builder.shippingAddress.state,
                    country: builder.shippingAddress.country,
                },
            };
        }
        const [phoneNumber, phoneCountryCode] = this.getPhoneNumber(builder, src_1.PhoneNumberType.SHIPPING);
        if (phoneCountryCode || phoneNumber) {
            order["shipping_phone"] = {
                country_code: phoneCountryCode,
                subscriber_number: phoneNumber,
            };
        }
        switch (true) {
            case builder.paymentMethod instanceof src_1.AlternativePaymentMethod:
                if (builder.productData) {
                    order = {
                        ...order,
                        ...this.setItemDetailsListForApm(builder),
                    };
                }
                break;
        }
        if (request.order) {
            order = {
                ...order,
                ...request.order,
            };
        }
        return Object.keys(order).length ? order : undefined;
    }
    setItemDetailsListForApm(builder) {
        let taxTotalAmount = 0;
        let itemsAmount = 0;
        let orderAmount = 0;
        const items = [];
        const order = {};
        for (const product of builder.productData) {
            const qta = product.quantity ?? 0;
            const taxAmount = src_1.StringUtils.toNumeric(product.tax_amount);
            const unitAmount = src_1.StringUtils.toNumeric(product.unit_amount);
            items.push({
                reference: product.reference ?? null,
                label: product.label ?? null,
                description: product.description ?? null,
                quantity: qta,
                unit_amount: unitAmount,
                unit_currency: product.unit_currency ?? null,
                tax_amount: taxAmount,
                amount: (Number(qta) * Number(unitAmount)).toString(),
            });
            if (product.tax_amount) {
                taxTotalAmount += Number(product.tax_amount);
            }
            if (product.unit_amount) {
                itemsAmount += Number(product.quantity) * Number(product.unit_amount);
            }
        }
        order.tax_amount = src_1.StringUtils.toNumeric(taxTotalAmount.toString());
        order.item_amount = src_1.StringUtils.toNumeric(itemsAmount.toString());
        if (builder.shippingAmount) {
            order.shipping_amount = src_1.StringUtils.toNumeric(String(builder.shippingAmount || ""));
            orderAmount += Number(builder.shippingAmount);
        }
        order.insurance_offered =
            builder.orderDetails && builder.orderDetails.hasInsurance !== undefined
                ? builder.orderDetails.hasInsurance
                    ? "YES"
                    : "NO"
                : null;
        order.shipping_discount = builder.shippingDiscount
            ? src_1.StringUtils.toNumeric(builder.shippingDiscount)
            : 0;
        if (builder.orderDetails && builder.orderDetails.insuranceAmount) {
            order.insurance_amount = src_1.StringUtils.toNumeric(String(builder.orderDetails.insuranceAmount || ""));
            orderAmount += Number(builder.orderDetails.insuranceAmount);
        }
        if (builder.orderDetails && builder.orderDetails.handlingAmount) {
            order.handling_amount = src_1.StringUtils.toNumeric(String(builder.orderDetails.handlingAmount || ""));
            orderAmount += Number(builder.orderDetails.handlingAmount);
        }
        orderAmount += itemsAmount + taxTotalAmount;
        order.amount = src_1.StringUtils.toNumeric(String(orderAmount || ""));
        order.currency = builder.currency ?? null;
        order.items = items;
        return order;
    }
    setRequestStoredCredentials(storedCredential, request) {
        request.initiator = null;
        if (storedCredential.initiator) {
            request.initiator = src_1.EnumMapping.mapStoredCredentialInitiator(src_1.GatewayProvider.GpApi, storedCredential.initiator);
        }
        request.stored_credential = {
            model: storedCredential.type ? storedCredential.type.toUpperCase() : null,
            reason: storedCredential.reason
                ? storedCredential.reason.toUpperCase()
                : null,
            sequence: storedCredential.sequence
                ? storedCredential.sequence.toUpperCase()
                : null,
        };
    }
    setPayerInformation(builder) {
        const payer = {};
        if (builder.customerId || builder.customerData?.id) {
            payer["id"] = builder.customerId || builder.customerData?.id;
        }
        if (builder.customerData) {
            payer["reference"] = builder.customerData.key;
        }
        switch (builder.paymentMethod.constructor) {
            case src_1.AlternativePaymentMethod:
                if (builder.homePhone?.countryCode || builder.homePhone?.number) {
                    payer["home_phone"] = {
                        country_code: builder.homePhone?.countryCode
                            ? src_1.StringUtils.validateToNumber(builder.homePhone.countryCode)
                            : undefined,
                        subscriber_number: builder.homePhone?.number
                            ? src_1.StringUtils.validateToNumber(builder.homePhone.number)
                            : undefined,
                    };
                }
                if (builder.workPhone?.countryCode || builder.workPhone?.number) {
                    payer["work_phone"] = {
                        country_code: builder.workPhone?.countryCode
                            ? src_1.StringUtils.validateToNumber(builder.workPhone.countryCode)
                            : undefined,
                        subscriber_number: builder.workPhone?.number
                            ? src_1.StringUtils.validateToNumber(builder.workPhone.number)
                            : undefined,
                    };
                }
                break;
            case src_1.ECheck:
                payer["billing_address"] = {
                    line_1: builder.billingAddress.streetAddress1,
                    line_2: builder.billingAddress.streetAddress2,
                    city: builder.billingAddress.city,
                    postal_code: builder.billingAddress.postalCode,
                    state: builder.billingAddress.state,
                    country: builder.billingAddress.countryCode,
                };
                if (builder.customerData) {
                    const payerName = `${builder.customerData.firstName} ${builder.customerData.lastName}`;
                    payer["name"] = payerName;
                    payer["date_of_birth"] = builder.customerData.dateOfBirth;
                }
                const homePhone = this.getPhoneNumber(builder, src_1.PhoneNumberType.HOME);
                payer["landline_phone"] = homePhone[1] + homePhone[0];
                const mobilePhone = this.getPhoneNumber(builder, src_1.PhoneNumberType.MOBILE);
                payer["mobile_phone"] = mobilePhone[1] + mobilePhone[0];
                break;
            default:
                break;
        }
        return Object.keys(payer).length ? payer : undefined;
    }
    getPhoneNumber(builder, type) {
        const phoneKey = type.toLowerCase() + "Phone";
        let phoneCountryCode = "";
        let phoneNumber = "";
        if (builder.customerData &&
            builder.customerData[phoneKey] &&
            builder.customerData[phoneKey] instanceof src_1.PhoneNumber) {
            phoneCountryCode = builder.customerData[phoneKey].countryCode;
            phoneNumber = builder.customerData[phoneKey].number;
        }
        if (phoneNumber === "" &&
            builder[phoneKey] &&
            builder[phoneKey] instanceof src_1.PhoneNumber) {
            phoneCountryCode = builder[phoneKey].countryCode;
            phoneNumber = builder[phoneKey].number;
        }
        return [
            src_1.StringUtils.validateToNumber(phoneNumber),
            src_1.StringUtils.validateToNumber(phoneCountryCode),
        ];
    }
    getEntryMode(builder, channel) {
        if (channel === src_1.Channel.CardPresent) {
            if (builder.paymentMethod.isTrackData) {
                if (builder.tagData) {
                    if (builder.paymentMethod.entryMethod === src_1.EntryMethod.Proximity) {
                        return src_1.PaymentEntryMode.CONTACTLESS_CHIP;
                    }
                    return src_1.PaymentEntryMode.CHIP;
                }
                if (builder.paymentMethod.entryMethod === src_1.PaymentEntryMode.SWIPE) {
                    return src_1.PaymentEntryMode.SWIPE;
                }
            }
            if (builder.paymentMethod.isCardData &&
                builder.paymentMethod.cardPresent) {
                return src_1.PaymentEntryMode.MANUAL;
            }
            return src_1.PaymentEntryMode.SWIPE;
        }
        else if (channel === src_1.Channel.CardNotPresent) {
            if (builder.paymentMethod.isCardData) {
                if (builder.paymentMethod.readerPresent === true) {
                    return src_1.PaymentEntryMode.ECOM;
                }
                if (builder.paymentMethod.readerPresent === false &&
                    builder.paymentMethod.entryMethod) {
                    switch (builder.paymentMethod.entryMethod) {
                        case src_1.ManualEntryMethod.PHONE:
                            return src_1.PaymentEntryMode.PHONE;
                        case src_1.ManualEntryMethod.MOTO:
                            return src_1.PaymentEntryMode.MOTO;
                        case src_1.ManualEntryMethod.MAIL:
                            return src_1.PaymentEntryMode.MAIL;
                        default:
                            break;
                    }
                }
                if (builder.transactionModifier === src_1.TransactionModifier.EncryptedMobile &&
                    builder.paymentMethod instanceof src_1.CreditCardData &&
                    builder.paymentMethod.hasInAppPaymentData()) {
                    return src_1.PaymentEntryMode.IN_APP;
                }
            }
            return src_1.PaymentEntryMode.ECOM;
        }
        throw new src_1.ApiError("Please configure the channel!");
    }
    getCaptureMode(builder) {
        if (builder.multiCapture) {
            return src_1.CaptureMode.MULTIPLE;
        }
        if (builder.transactionType === src_1.TransactionType.Auth) {
            return src_1.CaptureMode.LATER;
        }
        return src_1.CaptureMode.AUTO;
    }
    mapFraudManagement() {
        let rules;
        if (this.builder.fraudRules && this.builder.fraudRules.length > 0) {
            rules = this.builder.fraudRules.map((fraudRule) => ({
                reference: fraudRule.key,
                mode: fraudRule.mode,
            }));
        }
        return {
            mode: this.builder.fraudFilter,
            rules: rules || undefined,
        };
    }
    buildRequestFromJson(jsonRequest, config) {
        // TODO: Implement buildRequestFromJson() method.
        jsonRequest;
        config;
    }
}
exports.GpApiAuthorizationRequestBuilder = GpApiAuthorizationRequestBuilder;
//# sourceMappingURL=GpApiAuthorizationRequestBuilder.js.map