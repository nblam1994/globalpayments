"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GpApiManagementRequestBuilder = void 0;
const src_1 = require("../../../../src");
const DTO_1 = require("../../../../src/Entities/GpApi/DTO");
class GpApiManagementRequestBuilder {
    maskedValues = {};
    canProcess(builder) {
        return builder instanceof src_1.ManagementBuilder;
    }
    buildRequest(builder) {
        let payload = {};
        let endpoint = "";
        let verb = "";
        switch (builder.transactionType) {
            case src_1.TransactionType.TokenDelete:
                endpoint =
                    src_1.GpApiRequest.PAYMENT_METHODS_ENDPOINT +
                        "/" +
                        (builder.paymentMethod?.token || "");
                verb = "DELETE";
                break;
            case src_1.TransactionType.TokenUpdate:
                if (!(builder.paymentMethod instanceof src_1.CreditCardData)) {
                    throw new src_1.GatewayError("Payment method doesn't support this action!");
                }
                endpoint =
                    src_1.GpApiRequest.PAYMENT_METHODS_ENDPOINT +
                        "/" +
                        builder.paymentMethod.token;
                verb = "PATCH";
                const card = new DTO_1.Card();
                const builderCard = builder.paymentMethod;
                card.expiry_month = builderCard.expMonth
                    ? builderCard.expMonth.toString()
                    : "";
                card.expiry_year = builderCard.expYear
                    ? builderCard.expYear.toString().padStart(4, "0").substr(2, 2)
                    : "";
                if (builderCard.number) {
                    card.number = builderCard.number;
                }
                this.maskedValues = {
                    ...this.maskedValues,
                    ...src_1.ProtectSensitiveData.hideValue("card.number", card.number, 4, 6),
                    ...src_1.ProtectSensitiveData.hideValues({
                        "card.expiry_year": card.expiry_year,
                        "card.expiry_month": card.expiry_month,
                    }),
                };
                this.maskedValues = {
                    ...this.maskedValues,
                    ...src_1.ProtectSensitiveData.hideValues({
                        "card.expiry_year": card.expiry_year,
                        "card.expiry_month": card.expiry_month,
                    }),
                };
                payload = {
                    usage_mode: builder.paymentMethodUsageMode || undefined,
                    name: builderCard.cardHolderName || undefined,
                    card: card,
                };
                break;
            case src_1.TransactionType.Capture:
                endpoint =
                    src_1.GpApiRequest.TRANSACTION_ENDPOINT +
                        "/" +
                        builder.paymentMethod.transactionId +
                        "/capture";
                verb = "POST";
                payload = {
                    amount: builder.amount && src_1.StringUtils.toNumeric(builder.amount),
                    gratuity: builder.gratuity && src_1.StringUtils.toNumeric(builder.gratuity),
                    currency_conversion: builder.dccRateData
                        ? this.getDccRate(builder.dccRateData)
                        : undefined,
                };
                break;
            case src_1.TransactionType.DisputeAcceptance:
                endpoint =
                    src_1.GpApiRequest.DISPUTES_ENDPOINT +
                        "/" +
                        builder.disputeId +
                        "/acceptance";
                verb = "POST";
                break;
            case src_1.TransactionType.DisputeChallenge:
                endpoint =
                    src_1.GpApiRequest.DISPUTES_ENDPOINT +
                        "/" +
                        builder.disputeId +
                        "/challenge";
                verb = "POST";
                payload = {
                    documents: builder.disputeDocuments,
                };
                break;
            case src_1.TransactionType.Refund:
                endpoint =
                    src_1.GpApiRequest.TRANSACTION_ENDPOINT +
                        "/" +
                        builder.paymentMethod.transactionId +
                        "/refund";
                verb = "POST";
                payload = {
                    amount: builder.amount
                        ? src_1.StringUtils.toNumeric(builder.amount)
                        : undefined,
                    currency_conversion: builder.dccRateData
                        ? this.getDccRate(builder.dccRateData)
                        : undefined,
                };
                break;
            case src_1.TransactionType.Reversal:
                endpoint =
                    src_1.GpApiRequest.TRANSACTION_ENDPOINT +
                        "/" +
                        builder.paymentMethod.transactionId +
                        "/reversal";
                if (builder.paymentMethod.paymentMethodType ===
                    src_1.PaymentMethodType.Account_Funds) {
                    if (builder.fundsData.merchantId) {
                        endpoint =
                            src_1.GpApiRequest.MERCHANT_MANAGEMENT_ENDPOINT +
                                "/" +
                                builder.fundsData.merchantId;
                    }
                }
                verb = "POST";
                payload = {
                    amount: src_1.StringUtils.toNumeric(builder.amount),
                    currency_conversion: builder.dccRateData
                        ? this.getDccRate(builder.dccRateData)
                        : undefined,
                };
                break;
            case src_1.TransactionType.Reauth:
                endpoint = `${src_1.GpApiRequest.TRANSACTION_ENDPOINT}/${builder.paymentMethod.transactionId}/reauthorization`;
                verb = "POST";
                payload.amount = src_1.StringUtils.toNumeric(builder.amount);
                if (builder.paymentMethod.paymentMethodType === src_1.PaymentMethodType.ACH) {
                    payload.description = builder.description;
                }
                break;
            case src_1.TransactionType.Edit:
                endpoint = `${src_1.GpApiRequest.TRANSACTION_ENDPOINT}/${builder.paymentMethod.transactionId}/adjustment`;
                verb = "POST";
                if (builder.amount || builder.amount === 0) {
                    payload.amount = src_1.StringUtils.toNumeric(builder.amount);
                }
                if (builder.gratuity || builder.gratuity === 0) {
                    payload.gratuity_amount = src_1.StringUtils.toNumeric(builder.gratuity);
                }
                if (builder.tagData) {
                    payload.payment_method = {
                        card: {
                            tag: builder.tagData,
                        },
                    };
                }
                break;
            case src_1.TransactionType.Auth:
                endpoint = `${src_1.GpApiRequest.TRANSACTION_ENDPOINT}/${builder.paymentMethod.transactionId}/incremental`;
                verb = "POST";
                if (builder.amount || builder.amount === 0) {
                    payload.amount = src_1.StringUtils.toNumeric(builder.amount);
                }
                if (builder.lodgingData) {
                    const lodging = builder.lodgingData;
                    const lodgingItems = [];
                    if (lodging.items && lodging.items.length > 0) {
                        for (const item of lodging.items) {
                            lodgingItems.push({
                                types: item.types,
                                reference: item.reference,
                                total_amount: item.totalAmount
                                    ? src_1.StringUtils.toNumeric(item.totalAmount)
                                    : null,
                                payment_method_program_codes: item.paymentMethodProgramCodes,
                            });
                        }
                    }
                    payload.lodging = {
                        booking_reference: lodging.bookingReference,
                        duration_days: lodging.durationDays,
                        date_checked_in: lodging.checkedInDate
                            ? new Date(lodging.checkedInDate).toISOString().split("T")[0]
                            : null,
                        date_checked_out: lodging.checkedOutDate
                            ? new Date(lodging.checkedOutDate).toISOString().split("T")[0]
                            : null,
                        daily_rate_amount: lodging.dailyRateAmount
                            ? src_1.StringUtils.toNumeric(lodging.dailyRateAmount)
                            : null,
                        "lodging.charge_items": lodgingItems || null,
                    };
                }
                break;
            case src_1.TransactionType.Confirm:
                if (builder.paymentMethod instanceof src_1.TransactionReference &&
                    builder.paymentMethod.paymentMethodType === src_1.PaymentMethodType.APM) {
                    endpoint =
                        src_1.GpApiRequest.TRANSACTION_ENDPOINT +
                            "/" +
                            builder.paymentMethod.transactionId +
                            "/confirmation";
                    verb = "POST";
                    const apmResponse = builder.paymentMethod.alternativePaymentResponse;
                    payload = {
                        payment_method: {
                            apm: {
                                provider: apmResponse.providerName,
                                provider_payer_reference: apmResponse.providerReference,
                            },
                        },
                    };
                }
                break;
        }
        src_1.GpApiRequest.maskedValues = this.maskedValues;
        return new src_1.GpApiRequest(endpoint, verb, JSON.stringify(payload));
    }
    getDccRate(dccRateData) {
        return {
            id: dccRateData.dccId,
        };
    }
    buildRequestFromJson(jsonRequest) {
        jsonRequest;
        // Implement buildRequestFromJson() method if needed
    }
}
exports.GpApiManagementRequestBuilder = GpApiManagementRequestBuilder;
//# sourceMappingURL=GpApiManagementRequestBuilder.js.map