"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpaController = void 0;
const src_1 = require("../../../src");
const _1 = require(".");
const DeviceController_1 = require("../DeviceController");
const Enums_1 = require("../Enums");
const TerminalUtils_1 = require("../TerminalUtils");
class UpaController extends DeviceController_1.DeviceController {
    deviceConfig;
    constructor(config) {
        super(config);
        this.requestIdProvider = config.requestIdProvider;
    }
    configureInterface() {
        if (this._interface == null) {
            this._interface = new _1.UpaInterface(this);
        }
        return this._interface;
    }
    manageTransaction(builder) {
        const request = this.buildManageTransaction(builder);
        return this.doTransaction(request);
    }
    processTransaction(builder) {
        const request = this.buildProcessTransaction(builder);
        return this.doTransaction(request);
    }
    buildManageTransaction(builder) {
        const transactionType = builder.transactionType;
        if (builder.paymentMethodType != src_1.PaymentMethodType.Credit &&
            builder.paymentMethodType != src_1.PaymentMethodType.Debit &&
            builder.paymentMethodType != src_1.PaymentMethodType.EBT) {
            throw new src_1.UnsupportedTransactionError("The supplied payment method type is not supported");
        }
        let requestId = builder.referenceNumber;
        if (!requestId && this.requestIdProvider) {
            requestId = this.requestIdProvider.getRequestId();
        }
        const request = {
            message: "MSG",
            data: {},
        };
        const requestData = {
            command: this.mapTransactionType(transactionType),
            ecrId: builder.ecrId,
            requestId: requestId.toString(),
        };
        const transactionData = {
            params: {
                clerkId: builder.clerkId,
            },
            transaction: {},
        };
        transactionData.transaction.referenceNumber = builder.transactionId;
        transactionData.transaction.amount = builder.amount?.toFixed(2);
        transactionData.transaction.taxAmount = builder.taxAmount;
        transactionData.transaction.tipAmount = builder.tipAmount;
        transactionData.transaction.taxIndicator = builder.taxIndicator;
        transactionData.transaction.invoiceNbr = builder.invoiceNumber;
        transactionData.transaction.processCPC = builder.processCPC;
        requestData.data = transactionData;
        request.data = requestData;
        return TerminalUtils_1.TerminalUtils.buildUpaRequest(request);
    }
    buildProcessTransaction(builder) {
        const transactionType = builder.transactionType;
        if (builder.paymentMethodType != src_1.PaymentMethodType.Credit &&
            builder.paymentMethodType != src_1.PaymentMethodType.Debit &&
            builder.paymentMethodType != src_1.PaymentMethodType.EBT) {
            throw new src_1.UnsupportedTransactionError("The supplied payment method type is not supported");
        }
        let requestId = builder.referenceNumber;
        if (!requestId && this.requestIdProvider) {
            requestId = this.requestIdProvider.getRequestId();
        }
        const request = {
            message: "MSG",
        };
        const requestData = {
            command: this.mapTransactionType(transactionType),
            ecrId: builder.ecrId?.toString(),
            requestId: requestId.toString(),
        };
        const transactionData = {
            params: {
                clerkId: builder.clerkId,
            },
            transaction: {},
        };
        if (!this.isTokenRequestApplicable(transactionType)) {
            transactionData.params.tokenRequest = builder.requestMultiUseToken
                ? "1"
                : "0";
        }
        if (builder.paymentMethod !== null &&
            builder.paymentMethod instanceof src_1.CreditCardData &&
            builder.paymentMethod.token !== "") {
            transactionData.params.tokenValue = builder.paymentMethod.token;
        }
        if (builder.requestMultiUseToken &&
            (transactionType == src_1.TransactionType.Sale ||
                transactionType == src_1.TransactionType.Refund ||
                transactionType == src_1.TransactionType.Verify ||
                transactionType == src_1.TransactionType.Auth)) {
            if (builder.cardOnFileIndicator) {
                transactionData.params.cardOnFileIndicator =
                    src_1.StoredCredentialInitiator.CardHolder ? "C" : "M";
            }
            if (builder.cardBrandTransId !== "") {
                transactionData.params.cardBrandTransId = builder.cardBrandTransId;
            }
        }
        transactionData.params.lineItemLeft = builder.lineItemLeft;
        transactionData.params.lineItemRight = builder.lineItemRight;
        if (transactionType === src_1.TransactionType.Auth) {
            transactionData.params.invoiceNbr = builder.invoiceNumber;
        }
        if (builder.shippingDate && builder.invoiceNumber !== null) {
            transactionData.params.directMktInvoiceNbr = builder.invoiceNumber;
            transactionData.params.directMktShipMonth = new Date(builder.shippingDate).getMonth();
            transactionData.params.directMktShipDay = new Date(builder.shippingDate).getDay();
        }
        if (transactionType != src_1.TransactionType.Verify &&
            transactionType != src_1.TransactionType.Refund &&
            // @ts-ignore
            transactionType != src_1.TransactionType.Tokenize) {
            if (transactionType === src_1.TransactionType.Auth) {
                transactionData.transaction.amount = builder.amount?.toFixed(2);
                transactionData.transaction.preAuthAmount =
                    builder.preAuthAmount?.toString(2);
            }
            else {
                transactionData.transaction.amount = builder.amount?.toFixed(2);
                transactionData.transaction.cashBackAmount =
                    builder.cashBackAmount?.toFixed(2);
                transactionData.transaction.tipAmount = builder.gratuity?.toFixed(2);
                transactionData.transaction.taxIndicator = builder.taxExempt;
                transactionData.transaction.invoiceNbr = builder.invoiceNumber;
                transactionData.transaction.processCPC = builder.processCPC;
                transactionData.transaction.taxAmount = builder.taxAmount;
            }
            transactionData.transaction.referenceNumber = builder.terminalRefNumber;
            transactionData.transaction.prescriptionAmount =
                builder.prescriptionAmount?.toFixed(2);
            transactionData.transaction.clinicAmount =
                builder.clinicAmount?.toFixed(2);
            transactionData.transaction.dentalAmount =
                builder.dentalAmount?.toFixed(2);
            transactionData.transaction.visionOpticalAmount =
                builder.visionOpticalAmount?.toFixed(2);
            transactionData.transaction.cardAcquisition =
                src_1.StoredCredentialInitiator.CardHolder ? "C" : "M";
        }
        if (transactionType === src_1.TransactionType.Refund) {
            transactionData.transaction.totalAmount = builder.amount?.toFixed(2);
            transactionData.transaction.invoiceNbr = builder.invoiceNumber;
            transactionData.transaction.referenceNumber = builder.terminalRefNumber;
        }
        requestData.data = transactionData;
        request.data = requestData;
        return TerminalUtils_1.TerminalUtils.buildUpaRequest(request);
    }
    isTokenRequestApplicable(transactionType) {
        switch (transactionType) {
            case src_1.TransactionType.Refund:
                return true;
            default:
                return false;
        }
    }
    mapTransactionType(type) {
        switch (type) {
            case src_1.TransactionType.Sale:
                return _1.UpaMessageId.SALE;
            case src_1.TransactionType.Auth:
                return _1.UpaMessageId.PRE_AUTH;
            case src_1.TransactionType.Capture:
                return _1.UpaMessageId.AUTH_COMPLETION;
            case src_1.TransactionType.Refund:
                return _1.UpaMessageId.REFUND;
            case src_1.TransactionType.Verify:
                return _1.UpaMessageId.CARD_VERIFY;
            case src_1.TransactionType.Void:
                return _1.UpaMessageId.VOID;
            default:
                throw new src_1.UnsupportedTransactionError("The selected gateway does not support this transaction type.");
        }
    }
    async doTransaction(request) {
        const response = await this.connector.send(request);
        if (!response) {
            throw new src_1.GatewayError("No gateway response!");
        }
        return new _1.TransactionResponse(response);
    }
    configureConnector() {
        switch (this._settings.connectionMode) {
            case Enums_1.ConnectionModes.HTTP:
            case Enums_1.ConnectionModes.SERIAL:
            case Enums_1.ConnectionModes.SSL_TCP:
            case Enums_1.ConnectionModes.MEET_IN_THE_CLOUD:
                if (this._settings.gatewayConfig instanceof src_1.GpApiConfig) {
                    return new _1.UpaMicInterface(this._settings);
                }
            case Enums_1.ConnectionModes.TCP_IP:
            default:
                throw new src_1.NotImplementedError();
        }
    }
}
exports.UpaController = UpaController;
//# sourceMappingURL=UpaController.js.map