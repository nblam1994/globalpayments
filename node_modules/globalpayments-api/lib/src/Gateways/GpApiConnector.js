"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GpApiConnector = void 0;
const fs = __importStar(require("fs"));
const RestGateway_1 = require("./RestGateway");
const Entities_1 = require("../../src/Entities");
const src_1 = require("../../src");
class GpApiConnector extends RestGateway_1.RestGateway {
    static GP_API_VERSION = "2021-03-22";
    static IDEMPOTENCY_HEADER = "x-gp-idempotency";
    gpApiConfig;
    accessToken;
    builtInMerchantManagementService = true;
    supportsHostedPayments = true;
    supportsOpenBanking() {
        return true;
    }
    hasBuiltInMerchantManagementService() {
        return this.builtInMerchantManagementService;
    }
    constructor(config) {
        super();
        this.gpApiConfig = config;
        this.headers["X-GP-Version"] = GpApiConnector.GP_API_VERSION;
        this.headers["Accept"] = "application/json";
        this.headers["Accept-Encoding"] = "gzip";
        this.headers["x-gp-sdk"] = "node;version=" + this.getReleaseVersion();
        this.headers["Content-Type"] = "charset=UTF-8";
    }
    /**
     * Get the SDK release version
     *
     * @return string|null
     */
    getReleaseVersion() {
        const filename = __dirname + "/../../../package.json";
        if (!fs.existsSync(filename)) {
            return null;
        }
        const packageJson = JSON.parse(fs.readFileSync(filename).toString());
        return packageJson.version || "";
    }
    getVersion() {
        return Entities_1.Secure3dVersion.ANY;
    }
    /**
     * Serializes and executes authorization transactions
     *
     * @param AuthorizationBuilder builder The transaction's builder
     *
     * @return Transaction
     */
    async processAuthorization(builder) {
        if (!this.accessToken) {
            await this.signIn();
        }
        return this.executeProcess(builder).then((response) => {
            if (builder.paymentMethod instanceof src_1.AlternativePaymentMethod) {
                return src_1.GpApiMapping.mapResponseAPM(response);
            }
            return src_1.GpApiMapping.mapResponse(response);
        });
    }
    async signIn() {
        let accessTokenInfo = this.gpApiConfig.accessTokenInfo;
        if (accessTokenInfo && accessTokenInfo.accessToken) {
            this.headers["Authorization"] = `Bearer ${accessTokenInfo.accessToken}`;
            return;
        }
        const response = await this.getAccessToken();
        this.accessToken = response.getToken();
        this.headers["Authorization"] = `Bearer ${this.accessToken}`;
        if (!(accessTokenInfo instanceof Entities_1.AccessTokenInfo)) {
            accessTokenInfo = new Entities_1.AccessTokenInfo();
        }
        accessTokenInfo.merchantId = response.merchantId;
        if (!accessTokenInfo.accessToken) {
            accessTokenInfo.accessToken = response.getToken();
        }
        if (!accessTokenInfo.dataAccountID) {
            accessTokenInfo.dataAccountID = response.getDataAccountID();
        }
        if (!accessTokenInfo.tokenizationAccountID &&
            !accessTokenInfo.tokenizationAccountName) {
            accessTokenInfo.tokenizationAccountID =
                response.getTokenizationAccountID();
        }
        if (!accessTokenInfo.transactionProcessingAccountID &&
            !accessTokenInfo.transactionProcessingAccountName) {
            accessTokenInfo.transactionProcessingAccountID =
                response.getTransactionProcessingAccountID();
            accessTokenInfo.transactionProcessingAccountName =
                response.getTransactionProcessingAccountName();
        }
        if (!accessTokenInfo.disputeManagementAccountID &&
            !accessTokenInfo.disputeManagementAccountName) {
            accessTokenInfo.disputeManagementAccountID =
                response.getDisputeManagementAccountID();
        }
        if (!accessTokenInfo.riskAssessmentAccountID &&
            !accessTokenInfo.riskAssessmentAccountName) {
            accessTokenInfo.riskAssessmentAccountID =
                response.getRiskAssessmentAccountID();
        }
        if (!accessTokenInfo.merchantManagementAccountID &&
            !accessTokenInfo.merchantManagementAccountName) {
            accessTokenInfo.merchantManagementAccountID =
                response.getMerchantManagementAccountID();
        }
        this.gpApiConfig.accessTokenInfo = accessTokenInfo;
    }
    async getAccessToken() {
        this.accessToken = "";
        const request = await src_1.GpApiSessionInfo.signIn(this.gpApiConfig.appId, this.gpApiConfig.appKey, this.gpApiConfig.secondsToExpire, this.gpApiConfig.intervalToExpire, this.gpApiConfig.permissions);
        return super
            .doTransaction(request.httpVerb, request.endpoint, request.requestBody)
            .then((response) => new Entities_1.GpApiTokenResponse(response));
    }
    async manageTransaction(builder) {
        if (!this.accessToken) {
            await this.signIn();
        }
        return this.executeProcess(builder).then((response) => {
            if (builder.paymentMethod instanceof src_1.AlternativePaymentMethod) {
                return src_1.GpApiMapping.mapResponseAPM(response);
            }
            return src_1.GpApiMapping.mapResponse(response);
        });
    }
    async processReport(builder) {
        if (!this.accessToken) {
            await this.signIn();
        }
        return this.executeProcess(builder).then((response) => src_1.GpApiMapping.mapReportResponse(response, builder.reportType));
    }
    serializeRequest(builder) {
        builder; // avoid lint error
        throw new Entities_1.NotImplementedError();
    }
    async processPayFac(builder) {
        builder; // avoid lint error
        throw new Entities_1.NotImplementedError();
    }
    executeProcess(builder) {
        const processFactory = new src_1.RequestBuilderFactory();
        const requestBuilder = processFactory.getRequestBuilder(builder, this.gpApiConfig.gatewayProvider);
        if (!requestBuilder) {
            throw new Entities_1.ApiError("Request builder not found!");
        }
        /**.
         * @var GpApiRequest request
         */
        const request = requestBuilder.buildRequest(builder, this.gpApiConfig);
        request.endpoint = this.getMerchantUrl(request) + request.endpoint;
        if (!request) {
            throw new Entities_1.ApiError("Request was not generated!");
        }
        const idempotencyKey = builder.idempotencyKey || null;
        if (Entities_1.GpApiRequest.maskedValues) {
            this.maskedRequestData = Entities_1.GpApiRequest.maskedValues;
        }
        return this.doTransaction(request.httpVerb, request.endpoint, request.requestBody, request.queryParams, idempotencyKey);
    }
    getMerchantUrl(request) {
        return !this.gpApiConfig.merchantId &&
            request.endpoint.indexOf(Entities_1.GpApiRequest.MERCHANT_MANAGEMENT_ENDPOINT) !== -1
            ? Entities_1.GpApiRequest.MERCHANT_MANAGEMENT_ENDPOINT +
                "/" +
                this.gpApiConfig.merchantId
            : "";
    }
    async doTransaction(verb, endpoint, data, queryStringParams, idempotencyKey) {
        if (!this.accessToken) {
            await this.signIn();
        }
        if (idempotencyKey) {
            this.headers[GpApiConnector.IDEMPOTENCY_HEADER] = idempotencyKey;
        }
        //weird bug where if you populate the contentType header on this endpoint it throws a 502 bad gateway error
        //if you don't send it the error is even weirder, you just have to send it empty
        if (endpoint.indexOf("settlement") !== -1 ||
            (endpoint.indexOf("disputes") !== -1 &&
                endpoint.indexOf("challenge") !== -1)) {
            this.contentType = "";
        }
        if (endpoint.indexOf("/challenge") !== -1) {
            this.headers["Content-Type"] = "application/json";
        }
        let response;
        try {
            response = await super.doTransaction(verb, endpoint, data, queryStringParams);
        }
        catch (exception) {
            if (exception.message.indexOf("NOT_AUTHENTICATED") !== -1 &&
                this.gpApiConfig.appKey &&
                this.gpApiConfig.appKey) {
                this.accessToken = "";
                await this.signIn();
                return await super.doTransaction(verb, endpoint, data, queryStringParams);
            }
            throw exception;
        }
        finally {
            delete this.headers[GpApiConnector.IDEMPOTENCY_HEADER];
        }
        return JSON.parse(response);
    }
    processPassThrough(jsonRequest) {
        if (!this.accessToken) {
            this.signIn();
        }
        const requestBuilder = new src_1.GpApiMiCRequestBuilder();
        const request = requestBuilder.buildRequestFromJson(jsonRequest, this.gpApiConfig);
        if (!request) {
            throw new Entities_1.GatewayError("Request was not generated!");
        }
        request.endpoint = this.getMerchantUrl(request) + request.endpoint;
        return this.doTransaction(request.httpVerb, request.endpoint, request.requestBody);
    }
    async processSecure3d(builder) {
        if (!this.accessToken) {
            await this.signIn();
        }
        const response = await this.executeProcess(builder);
        return src_1.GpApiMapping.mapResponseSecure3D(response);
    }
}
exports.GpApiConnector = GpApiConnector;
//# sourceMappingURL=GpApiConnector.js.map