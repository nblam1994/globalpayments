"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GpEcomConnector = void 0;
const elementtree_1 = require("@azz/elementtree");
const __1 = require("..");
const XmlGateway_1 = require("./XmlGateway");
const src_1 = require("../../src");
class GpEcomConnector extends XmlGateway_1.XmlGateway {
    merchantId;
    accountId;
    sharedSecret;
    channel;
    rebatePassword;
    refundPassword;
    supportsHostedPayments = true;
    supportsRetrieval = true;
    supportsUpdatePaymentDetails = true;
    hostedPaymentConfig;
    config;
    constructor(config) {
        super();
        this.config = config;
    }
    processAuthorization(builder) {
        const transactionType = src_1.GpEcomMapping.mapAuthRequestType(builder);
        const acceptedResponseCodes = this.mapAcceptedCodes(transactionType);
        return this.executeProcess(builder).then((response) => src_1.GpEcomMapping.mapResponse(response, acceptedResponseCodes));
    }
    manageTransaction(builder) {
        const transactionType = src_1.GpEcomMapping.mapManageRequestType(builder);
        return this.executeProcess(builder).then((response) => src_1.GpEcomMapping.mapResponse(response, this.mapAcceptedCodes(transactionType)));
    }
    executeProcess(builder) {
        const processFactory = new __1.RequestBuilderFactory();
        const requestBuilder = processFactory.getRequestBuilder(builder, this.config.gatewayProvider);
        if (!requestBuilder) {
            throw new __1.ApiError("Request builder not found!");
        }
        const request = requestBuilder.buildRequest(builder, this.config);
        if (!request) {
            throw new __1.ApiError("Request was not generated!");
        }
        if (__1.Request.maskedValues) {
            this.maskedRequestData = __1.Request.maskedValues;
        }
        return this.doTransaction(request.requestBody);
    }
    serializeRequest(builder) {
        if (!this.hostedPaymentConfig) {
            throw new __1.ApiError("Hosted configuration missing. Please check your configuration");
        }
        const encoder = this.hostedPaymentConfig.version === __1.HppVersion.Version2
            ? (t) => t
            : __1.StringUtils.btoa;
        const request = {};
        const orderId = builder.orderId || __1.GenerationUtils.generateOrderId();
        const timestamp = builder.timestamp || __1.GenerationUtils.generateTimestamp();
        if (builder.transactionType !== __1.TransactionType.Sale &&
            builder.transactionType !== __1.TransactionType.Auth &&
            builder.transactionType !== __1.TransactionType.Verify) {
            throw new __1.UnsupportedTransactionError();
        }
        request.MERCHANT_ID = encoder(this.merchantId || "");
        request.ACCOUNT = encoder(this.accountId || "");
        request.CHANNEL = encoder(this.channel || "");
        request.ORDER_ID = encoder(orderId || "");
        if (builder.amount) {
            request.AMOUNT = encoder(this.numberFormat(builder.amount) || "");
        }
        request.CURRENCY = encoder(builder.currency || "");
        request.TIMESTAMP = encoder(timestamp || "");
        request.AUTO_SETTLE_FLAG = encoder(builder.transactionType === __1.TransactionType.Sale ? "1" : "0" || "");
        request.COMMENT1 = encoder(builder.Description || "");
        // request.COMMENT2 = encoder( || "");
        if (this.hostedPaymentConfig.requestTransactionStabilityScore) {
            request.RETURN_TSS = encoder(this.hostedPaymentConfig.requestTransactionStabilityScore
                ? "1"
                : "0" || "");
        }
        if (this.hostedPaymentConfig.directCurrencyConversionEnabled) {
            request.DCC_ENABLE = encoder(this.hostedPaymentConfig.directCurrencyConversionEnabled
                ? "1"
                : "0" || "");
        }
        if (builder.hostedPaymentData) {
            request.CUST_NUM = encoder(builder.hostedPaymentData.customerNumber || "");
            if (this.hostedPaymentConfig.displaySavedCards &&
                builder.hostedPaymentData.customerKey) {
                request.HPP_SELECT_STORED_CARD = encoder(builder.hostedPaymentData.customerKey || "");
            }
            if (builder.hostedPaymentData.offerToSaveCard) {
                request.OFFER_SAVE_CARD = encoder(builder.hostedPaymentData.offerToSaveCard ? "1" : "0" || "");
            }
            if (builder.hostedPaymentData.customerExists) {
                request.PAYER_EXIST = encoder(builder.hostedPaymentData.customerExists ? "1" : "0" || "");
            }
            request.PAYER_REF = encoder(builder.hostedPaymentData.customerKey || "");
            request.PMT_REF = encoder(builder.hostedPaymentData.paymentKey || "");
            request.PROD_ID = encoder(builder.hostedPaymentData.productId || "");
            if (builder.hostedPaymentData.addressCapture !== undefined) {
                request.HPP_CAPTURE_ADDRESS = encoder(builder.hostedPaymentData.addressCapture ? "1" : "0" || "");
            }
            if (builder.hostedPaymentData.notReturnAddress !== undefined) {
                request.HPP_DO_NOT_RETURN_ADDRESS = encoder(builder.hostedPaymentData.notReturnAddress ? "1" : "0" || "");
            }
            if (builder.hostedPaymentData.removeShipping !== undefined) {
                request.HPP_REMOVE_SHIPPING = encoder(builder.hostedPaymentData.removeShipping ? "1" : "0" || "");
            }
        }
        if (builder.shippingAddress) {
            request.SHIPPING_CODE = encoder(builder.shippingAddress.postalCode || "");
            request.SHIPPING_CO = encoder(builder.shippingAddress.country || "");
        }
        if (builder.billingAddress) {
            request.BILLING_CODE = encoder(builder.billingAddress.postalCode || "");
            request.BILLING_CO = encoder(builder.billingAddress.country || "");
        }
        request.CUST_NUM = encoder(builder.customerId || "");
        request.VAR_REF = encoder(builder.clientTransactionId || "");
        request.HPP_LANG = encoder(this.hostedPaymentConfig.language || "");
        request.MERCHANT_RESPONSE_URL = encoder(this.hostedPaymentConfig.responseUrl || "");
        request.CARD_PAYMENT_BUTTON = encoder(this.hostedPaymentConfig.paymentButtonText || "");
        if (this.hostedPaymentConfig.cardStorageEnabled) {
            request.CARD_STORAGE_ENABLE = encoder(this.hostedPaymentConfig.cardStorageEnabled ? "1" : "0" || "");
        }
        if (builder.transactionType === __1.TransactionType.Verify) {
            request.VALIDATE_CARD_ONLY = encoder("1" || "");
        }
        if (this.hostedPaymentConfig.fraudFilterMode) {
            request.HPP_FRAUD_FILTER_MODE = encoder(this.hostedPaymentConfig.fraudFilterMode.toString() || "");
        }
        if (builder.recurringType || builder.recurringSequence) {
            if (builder.recurringType) {
                request.RECURRING_TYPE = encoder(builder.recurringType.toString().toLowerCase() || "");
            }
            if (builder.recurringSequence) {
                request.RECURRING_SEQUENCE = encoder(builder.recurringSequence.toString().toLowerCase() || "");
            }
        }
        if (this.hostedPaymentConfig.version) {
            request.HPP_VERSION = encoder(this.hostedPaymentConfig.version.toString() || "");
        }
        const toHash = [
            timestamp,
            this.merchantId,
            orderId,
            builder.amount ? this.numberFormat(builder.amount) : null,
            builder.currency,
        ];
        if (this.hostedPaymentConfig.cardStorageEnabled ||
            (builder.hostedPaymentData && builder.hostedPaymentData.offerToSaveCard)) {
            toHash.push(builder.hostedPaymentData.customerKey
                ? builder.hostedPaymentData.customerKey
                : null);
            toHash.push(builder.hostedPaymentData.paymentKey
                ? builder.hostedPaymentData.paymentKey
                : null);
        }
        if (this.hostedPaymentConfig.fraudFilterMode &&
            this.hostedPaymentConfig.fraudFilterMode !== __1.FraudFilterMode.None) {
            toHash.push(this.hostedPaymentConfig.fraudFilterMode.toString());
        }
        request.SHA1HASH = encoder(__1.GenerationUtils.generateHash(toHash.join("."), this.sharedSecret) || "");
        return JSON.stringify(request);
    }
    oldManageTransaction(builder) {
        const timestamp = __1.GenerationUtils.generateTimestamp();
        const orderId = builder.orderId || __1.GenerationUtils.generateOrderId();
        // build Request
        const request = (0, elementtree_1.Element)("request", {
            timestamp,
            type: this.mapManageRequestType(builder.transactionType),
        });
        if (this.merchantId) {
            (0, elementtree_1.SubElement)(request, "merchantid").append((0, elementtree_1.CData)(this.merchantId));
        }
        if (this.accountId) {
            (0, elementtree_1.SubElement)(request, "account").append((0, elementtree_1.CData)(this.accountId));
        }
        if (this.channel) {
            (0, elementtree_1.SubElement)(request, "channel").append((0, elementtree_1.CData)(this.channel));
        }
        (0, elementtree_1.SubElement)(request, "orderid").append((0, elementtree_1.CData)(orderId));
        if (builder.paymentMethod) {
            const ref = builder.paymentMethod;
            (0, elementtree_1.SubElement)(request, "pasref").append((0, elementtree_1.CData)(ref.transactionId));
        }
        if (builder.amount) {
            const amountAttrs = builder.currency
                ? { currency: builder.currency }
                : {};
            (0, elementtree_1.SubElement)(request, "amount", amountAttrs).append((0, elementtree_1.CData)(this.numberFormat(builder.amount)));
        }
        else if (builder.transactionType === __1.TransactionType.Capture) {
            throw new __1.BuilderError("Amount cannot be null for capture");
        }
        if (builder.transactionType === __1.TransactionType.Refund) {
            if (builder.authorizationCode) {
                (0, elementtree_1.SubElement)(request, "authcode").append((0, elementtree_1.CData)(builder.authorizationCode));
            }
            (0, elementtree_1.SubElement)(request, "refundhash").append((0, elementtree_1.CData)(__1.GenerationUtils.generateHash(this.rebatePassword)));
        }
        if (builder.reasonCode) {
            (0, elementtree_1.SubElement)(request, "reasoncode").append((0, elementtree_1.CData)(builder.reasonCode.toString()));
        }
        if (builder.description) {
            const comments = (0, elementtree_1.SubElement)(request, "comments");
            (0, elementtree_1.SubElement)(comments, "comment", { id: 1 }).append((0, elementtree_1.CData)(builder.description));
        }
        (0, elementtree_1.SubElement)(request, "sha1hash").append((0, elementtree_1.CData)(this.generateHash(timestamp, orderId, builder.amount ? this.numberFormat(builder.amount) : "", builder.currency, "")));
        return this.doTransaction(this.buildEnvelope(request)).then((response) => this.mapResponse(response));
    }
    processReport() {
        throw new __1.UnsupportedTransactionError("Reporting functionality is not supported through this gateway.");
    }
    processRecurring(builder) {
        const timestamp = __1.GenerationUtils.generateTimestamp();
        const orderId = builder.orderId || __1.GenerationUtils.generateOrderId();
        // build Request
        const request = (0, elementtree_1.Element)("request", {
            timestamp,
            type: this.mapRecurringRequestType(builder),
        });
        if (this.config.merchantId) {
            (0, elementtree_1.SubElement)(request, "merchantid").append((0, elementtree_1.CData)(this.config.merchantId));
        }
        if (builder.transactionType === __1.TransactionType.Create ||
            builder.transactionType === __1.TransactionType.Edit) {
            if (this.config.channel) {
                (0, elementtree_1.SubElement)(request, "channel").append((0, elementtree_1.CData)(this.config.channel));
            }
            if (this.config.accountId) {
                (0, elementtree_1.SubElement)(request, "account").append((0, elementtree_1.CData)(this.config.accountId));
            }
            if (builder.entity instanceof __1.Customer) {
                (0, elementtree_1.SubElement)(request, "orderid").append((0, elementtree_1.CData)(orderId));
                const customer = builder.entity;
                request.append(this.buildCustomer(customer, builder));
                (0, elementtree_1.SubElement)(request, "sha1hash").append((0, elementtree_1.CData)(__1.GenerationUtils.generateHash([
                    timestamp,
                    this.config.merchantId,
                    orderId,
                    "",
                    "",
                    customer.key,
                ].join("."), this.config.sharedSecret)));
            }
            else if (builder.entity instanceof __1.RecurringPaymentMethod) {
                const payment = builder.entity;
                const cardElement = (0, elementtree_1.SubElement)(request, "card");
                (0, elementtree_1.SubElement)(cardElement, "ref").append((0, elementtree_1.CData)(payment.key || payment.id));
                (0, elementtree_1.SubElement)(cardElement, "payerref").append((0, elementtree_1.CData)(payment.customerKey));
                if (payment.paymentMethod) {
                    const card = payment.paymentMethod;
                    const expiry = __1.StringUtils.leftPad(card.expMonth, 2, "0") +
                        __1.StringUtils.leftPad((card.expYear || "").substr(2, 2), 2, "0");
                    (0, elementtree_1.SubElement)(cardElement, "number").append((0, elementtree_1.CData)(card.number));
                    (0, elementtree_1.SubElement)(cardElement, "expdate").append((0, elementtree_1.CData)(expiry));
                    (0, elementtree_1.SubElement)(cardElement, "chname").append((0, elementtree_1.CData)(card.cardHolderName));
                    (0, elementtree_1.SubElement)(cardElement, "type").append((0, elementtree_1.CData)(card.getCardType().toUpperCase()));
                    let sha1hash = "";
                    if (builder.transactionType === __1.TransactionType.Create) {
                        sha1hash = __1.GenerationUtils.generateHash([
                            timestamp,
                            this.config.merchantId,
                            orderId,
                            "",
                            "",
                            payment.customerKey,
                            card.cardHolderName,
                            card.number,
                        ].join("."), this.config.sharedSecret);
                    }
                    else {
                        sha1hash = __1.GenerationUtils.generateHash([
                            timestamp,
                            this.config.merchantId,
                            payment.customerKey,
                            payment.key || payment.id,
                            expiry,
                            card.number,
                        ].join("."), this.config.sharedSecret);
                    }
                    (0, elementtree_1.SubElement)(request, "sha1hash").append((0, elementtree_1.CData)(sha1hash));
                }
            }
        }
        else if (builder.transactionType === __1.TransactionType.Delete) {
            if (builder.entity instanceof __1.RecurringPaymentMethod) {
                const payment = builder.entity;
                const cardElement = (0, elementtree_1.SubElement)(request, "card");
                (0, elementtree_1.SubElement)(cardElement, "ref").append((0, elementtree_1.CData)(payment.key || payment.id));
                (0, elementtree_1.SubElement)(cardElement, "payerref").append((0, elementtree_1.CData)(payment.customerKey));
            }
        }
        return this.doTransaction(this.buildEnvelope(request)).then((response) => this.mapRecurringResponse(response, builder));
    }
    buildEnvelope(transaction) {
        return new elementtree_1.ElementTree(transaction).write();
    }
    buildCustomer(customer, builder) {
        const payer = (0, elementtree_1.Element)("payer", {
            ref: customer.key || __1.StringUtils.uuid(),
        });
        const type = builder.transactionType === __1.TransactionType.Edit
            ? "Subscriber"
            : "Retail";
        (0, elementtree_1.SubElement)(payer, "type").append((0, elementtree_1.CData)(type));
        (0, elementtree_1.SubElement)(payer, "title").append((0, elementtree_1.CData)(customer.title));
        (0, elementtree_1.SubElement)(payer, "firstname").append((0, elementtree_1.CData)(customer.firstName));
        (0, elementtree_1.SubElement)(payer, "surname").append((0, elementtree_1.CData)(customer.lastName));
        (0, elementtree_1.SubElement)(payer, "company").append((0, elementtree_1.CData)(customer.company));
        if (customer.address) {
            const address = (0, elementtree_1.SubElement)(payer, "address");
            (0, elementtree_1.SubElement)(address, "line1").append((0, elementtree_1.CData)(customer.address.streetAddress1));
            (0, elementtree_1.SubElement)(address, "line2").append((0, elementtree_1.CData)(customer.address.streetAddress2));
            (0, elementtree_1.SubElement)(address, "line3").append((0, elementtree_1.CData)(customer.address.streetAddress3));
            (0, elementtree_1.SubElement)(address, "city").append((0, elementtree_1.CData)(customer.address.city));
            (0, elementtree_1.SubElement)(address, "county").append((0, elementtree_1.CData)(customer.address.province));
            (0, elementtree_1.SubElement)(address, "postcode").append((0, elementtree_1.CData)(customer.address.postalCode));
            if (customer.address.country) {
                (0, elementtree_1.SubElement)(address, "country", { code: "GB" }).append((0, elementtree_1.CData)(customer.address.country));
            }
        }
        const phone = (0, elementtree_1.SubElement)(payer, "phonenumbers");
        (0, elementtree_1.SubElement)(phone, "home").append((0, elementtree_1.CData)(customer.homePhone));
        (0, elementtree_1.SubElement)(phone, "work").append((0, elementtree_1.CData)(customer.workPhone));
        (0, elementtree_1.SubElement)(phone, "fax").append((0, elementtree_1.CData)(customer.fax));
        (0, elementtree_1.SubElement)(phone, "mobile").append((0, elementtree_1.CData)(customer.mobilePhone));
        (0, elementtree_1.SubElement)(payer, "email").append((0, elementtree_1.CData)(customer.email));
        return payer;
    }
    mapResponse(rawResponse) {
        const result = new __1.Transaction();
        const root = (0, elementtree_1.XML)(rawResponse);
        this.checkResponse(root);
        result.responseCode = root.findtext(".//result");
        result.responseMessage = root.findtext(".//message");
        result.cvnResponseCode = root.findtext(".//cvnresult");
        result.avsResponseCode = root.findtext(".//avspostcoderesponse");
        result.timestamp = root.findtext(".//timestamp");
        result.transactionReference = new __1.TransactionReference();
        result.transactionReference.authCode = root.findtext(".//authcode");
        result.transactionReference.orderId = root.findtext(".//orderid");
        result.transactionReference.paymentMethodType = __1.PaymentMethodType.Credit;
        result.transactionReference.transactionId = root.findtext(".//pasref");
        return result;
    }
    mapRecurringResponse(rawResponse, builder) {
        const root = (0, elementtree_1.XML)(rawResponse);
        this.checkResponse(root);
        return builder.entity;
    }
    checkResponse(root, acceptedCodes) {
        if (!acceptedCodes) {
            acceptedCodes = ["00"];
        }
        const responseCode = root.findtext(".//result");
        const responseMessage = root.findtext(".//message");
        if (acceptedCodes.indexOf(responseCode) === -1) {
            throw new __1.GatewayError(`Unexpected Gateway Response: ${responseCode} - ${responseMessage}`, responseCode, responseMessage);
        }
    }
    generateHash(timestamp, orderId, amount, currency, paymentData, verify = false) {
        const data = [timestamp, this.merchantId, orderId];
        if (false === verify) {
            data.push(amount);
            data.push(currency);
        }
        data.push(paymentData);
        return __1.GenerationUtils.generateHash(data.join("."), this.sharedSecret);
    }
    mapAuthRequestType(builder) {
        switch (builder.transactionType) {
            case __1.TransactionType.Sale:
            case __1.TransactionType.Auth:
                if (builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.Credit) {
                    if (builder.transactionModifier === __1.TransactionModifier.Offline) {
                        return "offline";
                    }
                    if (builder.transactionModifier === __1.TransactionModifier.EncryptedMobile) {
                        return "auth-mobile";
                    }
                    return "auth";
                }
                return "receipt-in";
            case __1.TransactionType.Capture:
                return "settle";
            case __1.TransactionType.Verify:
                if (builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.Credit) {
                    return "otb";
                }
                return "receipt-in-otb";
            case __1.TransactionType.Refund:
                if (builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.Credit) {
                    return "credit";
                }
                return "payment-out";
            case __1.TransactionType.Reversal:
                throw new __1.UnsupportedTransactionError("The selected gateway does not support this transaction type.");
            default:
                return "unknown";
        }
    }
    mapManageRequestType(type) {
        switch (type) {
            case __1.TransactionType.Capture:
                return "settle";
            case __1.TransactionType.Hold:
                return "hold";
            case __1.TransactionType.Refund:
                return "rebate";
            case __1.TransactionType.Release:
                return "release";
            case __1.TransactionType.Void:
            case __1.TransactionType.Reversal:
                return "void";
            default:
                return "unknown";
        }
    }
    mapRecurringRequestType(builder) {
        const entity = builder.entity;
        switch (builder.transactionType) {
            case __1.TransactionType.Create:
                if (entity instanceof __1.Customer) {
                    return "payer-new";
                }
                else if (entity instanceof __1.RecurringPaymentMethod) {
                    return "card-new";
                }
                else if (entity instanceof __1.Schedule) {
                    return "schedule-new";
                }
            case __1.TransactionType.Edit:
                if (entity instanceof __1.Customer) {
                    return "payer-edit";
                }
                if (entity instanceof __1.Schedule) {
                    throw new __1.UnsupportedTransactionError();
                }
                return "card-update-card";
            case __1.TransactionType.Delete:
                if (entity instanceof __1.Customer || entity instanceof __1.Schedule) {
                    throw new __1.UnsupportedTransactionError();
                }
                return "card-cancel-card";
            case __1.TransactionType.Fetch:
                if (entity instanceof __1.Schedule) {
                    return "schedule-get";
                }
            case __1.TransactionType.Search:
                if (entity instanceof __1.Schedule) {
                    return "schedule-search";
                }
            default:
                throw new __1.UnsupportedTransactionError();
        }
    }
    numberFormat(amount) {
        const f = parseFloat(amount.toString()) * 100;
        return parseFloat(f.toFixed(2)).toString();
    }
    mapAcceptedCodes(paymentMethodType) {
        switch (paymentMethodType) {
            case "3ds-verifysig":
            case "3ds-verifyenrolled":
                return ["00", "110"];
            case "payment-set":
                return ["01", "00"];
            default:
                return ["00"];
        }
    }
}
exports.GpEcomConnector = GpEcomConnector;
//# sourceMappingURL=GpEcomConnector.js.map