"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PayPlanConnector = void 0;
const __1 = require("../");
const RestGateway_1 = require("./RestGateway");
class PayPlanConnector extends RestGateway_1.RestGateway {
    supportsRetrieval = true;
    supportsUpdatePaymentDetails = false;
    _secretApiKey;
    siteId;
    licenseId;
    deviceId;
    _username;
    _password;
    developerId;
    versionNumber;
    get secretApiKey() {
        return this._secretApiKey;
    }
    set secretApiKey(value) {
        if (!value) {
            return;
        }
        this._secretApiKey = value;
        this.setAuthorizationHeader(this.secretApiKey);
    }
    get username() {
        return this._username;
    }
    set username(value) {
        if (!value) {
            return;
        }
        this._username = value;
        this.setAuthorizationHeader(`${this.username}:${this.password}`);
    }
    get password() {
        return this._password;
    }
    set password(value) {
        if (!value) {
            return;
        }
        this._password = value;
        this.setAuthorizationHeader(`${this.username}:${this.password}`);
    }
    processRecurring(builder) {
        let request = new Object();
        // todo
        if (builder.transactionType === __1.TransactionType.Create ||
            builder.transactionType === __1.TransactionType.Edit) {
            if (builder.entity instanceof __1.Customer) {
                request = this.buildCustomer(request, builder.entity);
            }
            if (builder.entity instanceof __1.RecurringPaymentMethod) {
                request = this.buildPaymentMethod(request, builder.entity, builder.transactionType);
            }
            if (builder.entity instanceof __1.Schedule) {
                request = this.buildSchedule(request, builder.entity, builder.transactionType);
            }
        }
        else if (builder.transactionType === __1.TransactionType.Search) {
            for (const entry in builder.searchCriteria) {
                if (builder.searchCriteria.hasOwnProperty(entry)) {
                    request[entry] = builder.searchCriteria[entry];
                }
            }
        }
        this.maybeSetIdentityHeader();
        this.maybeSetIntegrationHeader();
        return this.doTransaction(this.mapMethod(builder.transactionType), this.mapUrl(builder), JSON.stringify(request)).then((response) => this.mapResponse(builder, response));
    }
    mapResponse(builder, rawResponse) {
        if (!rawResponse) {
            return new Object();
        }
        const response = JSON.parse(rawResponse);
        let result;
        if ((builder.entity instanceof __1.Customer ||
            builder.entity.name === "Customer") &&
            builder.transactionType === __1.TransactionType.Search) {
            result = response.results.map((customer) => this.hydrateCustomer(customer));
        }
        else if (builder.entity instanceof __1.Customer) {
            result = this.hydrateCustomer(response);
        }
        if ((builder.entity instanceof __1.RecurringPaymentMethod ||
            builder.entity.name ===
                "RecurringPaymentMethod") &&
            builder.transactionType === __1.TransactionType.Search) {
            result = response.results.map((paymentMethod) => this.hydrateRecurringPaymentMethod(paymentMethod));
        }
        else if (builder.entity instanceof __1.RecurringPaymentMethod) {
            result = this.hydrateRecurringPaymentMethod(response);
        }
        if ((builder.entity instanceof __1.Schedule ||
            builder.entity.name === "Schedule") &&
            builder.transactionType === __1.TransactionType.Search) {
            result = response.results.map((schedule) => this.hydrateSchedule(schedule));
        }
        else if (builder.entity instanceof __1.Schedule) {
            result = this.hydrateSchedule(response);
        }
        return result;
    }
    buildCustomer(request, entity) {
        if (entity) {
            request.customerIdentifier = entity.id;
            request.firstName = entity.firstName;
            request.lastName = entity.lastName;
            request.company = entity.company;
            request.customerStatus = entity.status;
            request.primaryEmail = entity.email;
            request.phoneDay = entity.homePhone;
            request.phoneEvening = entity.workPhone;
            request.phoneMobile = entity.mobilePhone;
            request.fax = entity.fax;
            request.title = entity.title;
            request.department = entity.department;
            request = this.buildAddress(request, entity.address);
        }
        return request;
    }
    buildPaymentMethod(request, entity, transactionType) {
        if (entity) {
            request.preferredPayment = entity.preferredPayment;
            request.paymentMethodIdentifier = entity.id;
            request.customerKey = entity.customerKey;
            request.nameOnAccount = entity.nameOnAccount;
            request = this.buildAddress(request, entity.address);
            if (transactionType === __1.TransactionType.Create) {
                const { hasToken, tokenValue } = this.hasToken(entity.paymentMethod);
                const paymentInfo = {};
                if (entity.paymentMethod.isCardData) {
                    const method = entity.paymentMethod;
                    paymentInfo.type = hasToken ? "SINGLEUSETOKEN" : null;
                    paymentInfo[hasToken ? "token" : "number"] = hasToken
                        ? tokenValue
                        : method.number;
                    paymentInfo.expMon = method.expMonth;
                    paymentInfo.expYear = method.expYear;
                    request.cardVerificationValue = method.cvn;
                    request[hasToken ? "alternateIdentity" : "card"] = paymentInfo;
                }
                else if (entity.paymentMethod.isTrackData) {
                    const method = entity.paymentMethod;
                    paymentInfo.data = method.value;
                    paymentInfo.dataEntryMode = method.entryMethod
                        .toString()
                        .toUpperCase();
                    request.track = paymentInfo;
                }
                else if (entity.paymentMethod instanceof __1.ECheck) {
                    const check = entity.paymentMethod;
                    request.achType = this.prepareAccountType(check.accountType);
                    request.accountType = this.prepareCheckType(check.checkType);
                    request.telephoneIndicator =
                        check.secCode == __1.SecCode.CCD || check.secCode == __1.SecCode.PPD
                            ? false
                            : true;
                    request.routingNumber = check.routingNumber;
                    request.accountNumber = check.accountNumber;
                    if (check.birthYear) {
                        request.accountHolderYob = check.birthYear.toString();
                    }
                    request.driversLicenseState = check.driversLicenseState;
                    request.driversLicenseNumber = check.driversLicenseNumber;
                    request.socialSecurityNumberLast4 = check.ssnLast4;
                    delete request.country;
                }
                if (entity.paymentMethod.isEncryptable) {
                    const enc = entity.paymentMethod
                        .encryptionData;
                    if (enc) {
                        paymentInfo.trackNumber = enc.trackNumber;
                        paymentInfo.key = enc.ktb;
                        paymentInfo.encryptionType = "E3";
                    }
                }
            }
            else {
                // edit fields
                delete request.customerKey;
                request.paymentStatus = entity.status;
                delete request.cpcTaxType;
                delete request.expirationDate;
                delete request.country;
            }
        }
        return request;
    }
    buildSchedule(request, entity, transactionType) {
        const mapDuration = () => {
            if (entity.numberOfPayments) {
                return "Limited Number";
            }
            else if (entity.endDate) {
                return "End Date";
            }
            else {
                return "Ongoing";
            }
        };
        const mapProcessingDate = () => {
            const frequencies = [
                "Monthly",
                "Bi-Monthly",
                "Quarterly",
                "Semi-Annually",
            ];
            if (entity.frequency &&
                frequencies.indexOf(entity.frequency.toString()) !== -1) {
                switch (entity.paymentSchedule) {
                    case __1.PaymentSchedule.FirstDayOfTheMonth:
                        return "First";
                    case __1.PaymentSchedule.LastDayOfTheMonth:
                        return "Last";
                    default:
                        const day = entity.startDate.getUTCDate();
                        if (day > 28) {
                            return "Last";
                        }
                        return day.toString();
                }
            }
            else if (entity.frequency &&
                entity.frequency.toString() === "Semi-Monthly") {
                if (entity.paymentSchedule === __1.PaymentSchedule.LastDayOfTheMonth) {
                    return "Last";
                }
                return "First";
            }
            return null;
        };
        if (entity) {
            request.scheduleIdentifier = entity.id;
            request.scheduleName = entity.name;
            request.scheduleStatus = entity.status;
            request.paymentMethodKey = entity.paymentKey;
            request = this.buildAmount(request, "subtotalAmount", entity.amount, entity.currency, transactionType);
            request = this.buildAmount(request, "taxAmount", entity.taxAmount, entity.currency, transactionType);
            request.deviceId = entity.deviceId;
            request.processingDateInfo = mapProcessingDate();
            request = this.buildDate(request, "endDate", entity.endDate, transactionType === __1.TransactionType.Edit);
            request.reprocessingCount = entity.reprocessingCount || 3;
            if (entity.emailReceipt) {
                request.emailReceipt = entity.emailReceipt.toString();
            }
            request.emailAdvanceNotice = entity.emailNotification ? "Yes" : "No";
            // debt repay ind
            request.invoiceNbr = entity.invoiceNumber;
            request.poNumber = entity.poNumber;
            request.description = entity.description;
            request.numberOfPayments = entity.numberOfPayments;
            if (transactionType === __1.TransactionType.Create) {
                request.customerKey = entity.customerKey;
                request = this.buildDate(request, "startDate", entity.startDate);
                if (entity.frequency) {
                    request.frequency = entity.frequency.toString();
                }
                request.duration = mapDuration();
            }
            else {
                // edit Fields
                if (!entity.hasStarted) {
                    request = this.buildDate(request, "startDate", entity.startDate);
                    if (entity.frequency) {
                        request.frequency = entity.frequency.toString();
                    }
                    request.duration = mapDuration();
                }
                else {
                    request = this.buildDate(request, "cancellationDate", entity.cancellationDate);
                    request = this.buildDate(request, "nextProcressingDate", entity.nextProcessingDate);
                }
            }
        }
        return request;
    }
    prepareAccountType(type) {
        switch (type) {
            case __1.AccountType.Savings:
                return "Savings";
            case __1.AccountType.Checking:
            default:
                return "Checking";
        }
    }
    prepareCheckType(type) {
        switch (type) {
            case __1.CheckType.Business:
                return "Business";
            case __1.CheckType.Payroll:
                return "Payroll";
            case __1.CheckType.Personal:
            default:
                return "Personal";
        }
    }
    buildAddress(request, address) {
        if (address) {
            request.addressLine1 = address.streetAddress1;
            request.addressLine2 = address.streetAddress2;
            request.city = address.city;
            request.country = address.country;
            request.stateProvince = address.state;
            request.zipPostalCode = address.postalCode;
        }
        return request;
    }
    buildAmount(request, name, amount, currency, transactionType) {
        if (amount) {
            request[name] = {
                value: parseFloat(amount.toString()) * 100,
            };
            if (transactionType === __1.TransactionType.Create) {
                request[name].currency = currency;
            }
        }
        return request;
    }
    buildDate(request, name, date, force = false) {
        const getDateValue = (d) => {
            if (typeof date === "string" && date.length === 8) {
                return d;
            }
            const day = __1.StringUtils.leftPad(d.getUTCDate().toString(), 2, "0");
            const month = __1.StringUtils.leftPad((d.getUTCMonth() + 1).toString(), 2, "0");
            const year = __1.StringUtils.leftPad(d.getUTCFullYear().toString(), 4, "0");
            return month + day + year;
        };
        if (date || force) {
            const value = date ? getDateValue(date) : null;
            request[name] = value;
        }
        return request;
    }
    mapMethod(transactionType) {
        switch (transactionType) {
            case __1.TransactionType.Create:
            case __1.TransactionType.Search:
                return "POST";
            case __1.TransactionType.Edit:
                return "PUT";
            case __1.TransactionType.Delete:
                return "DELETE";
            default:
                return "GET";
        }
    }
    mapUrl(builder) {
        let suffix = "";
        if (builder.transactionType === __1.TransactionType.Fetch ||
            builder.transactionType === __1.TransactionType.Delete ||
            builder.transactionType === __1.TransactionType.Edit) {
            suffix = "/" + builder.entity.key;
        }
        if (builder.entity instanceof __1.Customer ||
            builder.entity.name === "Customer") {
            return ((builder.transactionType === __1.TransactionType.Search
                ? "searchCustomers"
                : "customers") + suffix);
        }
        if (builder.entity instanceof __1.RecurringPaymentMethod ||
            builder.entity.name === "RecurringPaymentMethod") {
            let paymentMethod = "";
            if (builder.transactionType === __1.TransactionType.Create) {
                paymentMethod =
                    builder.entity.paymentMethod instanceof __1.Credit
                        ? "CreditCard"
                        : "ACH";
            }
            else if (builder.transactionType === __1.TransactionType.Edit) {
                paymentMethod = builder.entity.paymentType.replace(" ", "");
            }
            return ((builder.transactionType === __1.TransactionType.Search
                ? "searchPaymentMethods"
                : "paymentMethods") +
                paymentMethod +
                suffix);
        }
        if (builder.entity instanceof __1.Schedule ||
            builder.entity.name === "Schedule") {
            return ((builder.transactionType === __1.TransactionType.Search
                ? "searchSchedules"
                : "schedules") + suffix);
        }
        throw new __1.UnsupportedTransactionError();
    }
    hydrateCustomer(response) {
        const customer = new __1.Customer();
        customer.key = response.customerKey;
        customer.id = response.customerIdentifier;
        customer.firstName = response.firstName;
        customer.lastName = response.lastName;
        customer.company = response.company;
        customer.status = response.customerStatus;
        customer.title = response.title;
        customer.department = response.department;
        customer.email = response.primaryEmail;
        customer.homePhone = response.phoneDay;
        customer.workPhone = response.phoneEvening;
        customer.mobilePhone = response.phoneMobile;
        customer.fax = response.fax;
        customer.address = new __1.Address();
        customer.address.streetAddress1 = response.addressLine1;
        customer.address.streetAddress2 = response.addressLine2;
        customer.address.city = response.city;
        customer.address.province = response.stateProvince;
        customer.address.postalCode = response.zipPostalCode;
        customer.address.country = response.country;
        customer.paymentMethods = new Array();
        if (response.paymentMethods) {
            response.paymentMethods.forEach((element) => {
                const paymentMethod = this.hydrateRecurringPaymentMethod(element);
                customer.paymentMethods.push(paymentMethod);
            });
        }
        return customer;
    }
    hydrateRecurringPaymentMethod(response) {
        const paymentMethod = new __1.RecurringPaymentMethod();
        paymentMethod.key = response.paymentMethodKey;
        paymentMethod.paymentType = response.paymentMethodType;
        paymentMethod.preferredPayment = response.preferredPayment;
        paymentMethod.status = response.paymentStatus;
        paymentMethod.id = response.paymentMethodIdentifier;
        paymentMethod.customerKey = response.customerKey;
        paymentMethod.nameOnAccount = response.nameOnAccount;
        paymentMethod.commercialIndicator = response.cpcInd;
        paymentMethod.taxType = response.cpcTaxType;
        paymentMethod.expirationDate = response.expirationDate;
        const address = new __1.Address();
        address.streetAddress1 = response.addressLine1;
        address.streetAddress2 = response.addressLine2;
        address.city = response.city;
        address.state = response.stateProvince;
        address.postalCode = response.zipPostalCode;
        address.country = response.country;
        paymentMethod.address = address;
        paymentMethod.lastFour = response.accountNumberLast4;
        paymentMethod.cardType = response.cardBrand;
        return paymentMethod;
    }
    hydrateSchedule(response) {
        const schedule = new __1.Schedule();
        schedule.key = response.scheduleKey;
        schedule.id = response.scheduleIdentifier;
        schedule.customerKey = response.customerKey;
        schedule.name = response.scheduleName;
        schedule.status = response.scheduleStatus;
        schedule.paymentKey = response.paymentMethodKey;
        if (response.subtotalAmount) {
            const subtotal = response.subtotalAmount;
            schedule.amount =
                subtotal.value.slice(0, -2) + "." + subtotal.value.slice(-2); // add the decimal back in
            schedule.currency = subtotal.currency;
        }
        if (response.taxAmount) {
            const taxAmount = response.taxAmount;
            schedule.taxAmount =
                taxAmount.value.slice(0, -2) + "." + taxAmount.value.slice(-2); // add the decimal back in
        }
        schedule.deviceId = response.deviceId;
        schedule.startDate = response.startDate === "" ? null : response.startDate;
        schedule.paymentSchedule = ((value) => {
            switch (value) {
                case "Last":
                    return __1.PaymentSchedule.LastDayOfTheMonth;
                case "First":
                    return __1.PaymentSchedule.FirstDayOfTheMonth;
                default:
                    return __1.PaymentSchedule.Dynamic;
            }
        })(response.processingDateInfo);
        schedule.frequency = response.frequency;
        schedule.endDate = response.endDate === "" ? null : response.endDate;
        schedule.reprocessingCount = response.reprocessingCount;
        schedule.emailReceipt = response.emailReceipt;
        schedule.emailNotification = ((value) => {
            if (!value) {
                return false;
            }
            return value === "No" ? false : true;
        })(response.emailNotification);
        // dept repay indicator
        schedule.invoiceNumber = response.invoiceNbr;
        schedule.poNumber = response.poNumber;
        schedule.description = response.description;
        // statusSetDate
        schedule.nextProcessingDate =
            response.nextProcessingDate === "" ? null : response.nextProcessingDate;
        // previousProcessingDate
        // approvedTransactionCount
        // failureCount
        // totalApprovedAmountToDate
        // numberOfPaymentsRemaining
        schedule.cancellationDate =
            response.cancellationDate === "" ? null : response.cancellationDate;
        // creationDate
        // lastChangeDate
        schedule.hasStarted = response.scheduleStarted;
        return schedule;
    }
    hasToken(paymentMethod) {
        const tokenizable = paymentMethod;
        if (tokenizable.token) {
            return {
                hasToken: true,
                tokenValue: tokenizable.token,
            };
        }
        return {
            hasToken: false,
            tokenValue: "",
        };
    }
    setAuthorizationHeader(value) {
        const buffer = Buffer.from ? Buffer.from(value) : new Buffer(value);
        const auth = `Basic ${buffer.toString("base64")}`;
        this.headers[RestGateway_1.RestGateway.AUTHORIZATION_HEADER] = auth;
    }
    maybeSetIdentityHeader() {
        const identity = [];
        if (this.siteId) {
            identity.push(`SiteID=${this.siteId}`);
        }
        if (this.deviceId) {
            identity.push(`DeviceID=${this.deviceId}`);
        }
        if (this.licenseId) {
            identity.push(`LicenseID=${this.licenseId}`);
        }
        if (identity.length > 0) {
            this.headers["HPS-Identity"] = identity.join(",");
        }
    }
    maybeSetIntegrationHeader() {
        if (this.versionNumber || this.developerId) {
            this.headers["HPS-Integration"] = `DeveloperId=${this.developerId},VersionNbr=${this.versionNumber}`;
        }
    }
}
exports.PayPlanConnector = PayPlanConnector;
//# sourceMappingURL=PayPlanConnector.js.map