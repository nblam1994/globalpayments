"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PorticoConnector = void 0;
const elementtree_1 = require("@azz/elementtree");
const __1 = require("../");
const InputValidation_1 = require("../Utils/InputValidation");
const XmlGateway_1 = require("./XmlGateway");
class PorticoConnector extends XmlGateway_1.XmlGateway {
    static XmlNamespace = "http://Hps.Exchange.PosGateway";
    siteId;
    licenseId;
    deviceId;
    username;
    password;
    secretApiKey;
    developerId;
    versionNumber;
    sdkNameVersion;
    supportsHostedPayments = false;
    uniqueDeviceId;
    config;
    constructor(config) {
        super();
        this.config = config;
    }
    processAuthorization(builder) {
        // build request
        const transaction = (0, elementtree_1.Element)(this.mapRequestType(builder));
        const block1 = (0, elementtree_1.SubElement)(transaction, "Block1");
        let allowDuplicates;
        if (builder.transactionType === __1.TransactionType.Sale ||
            builder.transactionType === __1.TransactionType.Auth) {
            if (builder.paymentMethod.paymentMethodType !== __1.PaymentMethodType.Gift &&
                builder.paymentMethod.paymentMethodType !== __1.PaymentMethodType.ACH) {
                allowDuplicates = (0, elementtree_1.SubElement)(block1, "AllowDup");
                allowDuplicates.append((0, elementtree_1.CData)(builder.allowDuplicates ? "Y" : "N"));
                if (builder.transactionModifier === __1.TransactionModifier.None &&
                    builder.paymentMethod.paymentMethodType !== __1.PaymentMethodType.EBT &&
                    builder.paymentMethod.paymentMethodType !==
                        __1.PaymentMethodType.Recurring) {
                    (0, elementtree_1.SubElement)(block1, "AllowPartialAuth").append((0, elementtree_1.CData)(builder.allowPartialAuth ? "Y" : "N"));
                }
            }
        }
        if (builder.amount !== undefined && builder.amount !== "") {
            (0, elementtree_1.SubElement)(block1, "Amt").append((0, elementtree_1.CData)((0, InputValidation_1.validateAmount)("portico", builder.amount)));
        }
        if (builder.gratuity) {
            (0, elementtree_1.SubElement)(block1, "GratuityAmtInfo").append((0, elementtree_1.CData)((0, InputValidation_1.validateAmount)("portico", builder.gratuity)));
        }
        if (builder.convenienceAmt) {
            (0, elementtree_1.SubElement)(block1, "ConvenienceAmtInfo").append((0, elementtree_1.CData)((0, InputValidation_1.validateAmount)("portico", builder.convenienceAmt)));
        }
        if (builder.shippingAmt) {
            (0, elementtree_1.SubElement)(block1, "ShippingAmtInfo").append((0, elementtree_1.CData)((0, InputValidation_1.validateAmount)("portico", builder.shippingAmt)));
        }
        if (builder.cashBackAmount !== undefined && builder.cashBackAmount !== "") {
            (0, elementtree_1.SubElement)(block1, 
            // because plano
            builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.Debit
                ? "CashbackAmtInfo"
                : "CashBackAmount").append((0, elementtree_1.CData)((0, InputValidation_1.validateAmount)("portico", builder.cashBackAmount)));
        }
        if (builder.offlineAuthCode) {
            (0, elementtree_1.SubElement)(block1, "OfflineAuthCode").append((0, elementtree_1.CData)(builder.offlineAuthCode));
        }
        if (builder.transactionType === __1.TransactionType.Alias) {
            (0, elementtree_1.SubElement)(block1, "Action").append((0, elementtree_1.CData)(builder.aliasAction.toString()));
            (0, elementtree_1.SubElement)(block1, "Alias").append((0, elementtree_1.CData)(builder.alias));
        }
        const isCheck = builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.ACH;
        const property = isCheck ? "checkHolderName" : "cardHolderName";
        if (builder.transactionType !== __1.TransactionType.Reversal &&
            (isCheck || builder.billingAddress || builder.paymentMethod[property])) {
            const holder = (0, elementtree_1.SubElement)(block1, isCheck ? "ConsumerInfo" : "CardHolderData");
            const pm = builder.paymentMethod;
            if (pm[property]) {
                const names = pm[property].split(" ", 2);
                (0, elementtree_1.SubElement)(holder, isCheck ? "FirstName" : "CardHolderFirstName").append((0, elementtree_1.CData)((0, InputValidation_1.validateInput)("portico", "firstName", names[0])));
                if (names[1]) {
                    (0, elementtree_1.SubElement)(holder, isCheck ? "LastName" : "CardHolderLastName").append((0, elementtree_1.CData)((0, InputValidation_1.validateInput)("portico", "lastName", names[1])));
                }
            }
            if (builder.billingAddress) {
                (0, elementtree_1.SubElement)(holder, isCheck ? "Address1" : "CardHolderAddr").append((0, elementtree_1.CData)(builder.billingAddress.streetAddress1));
                (0, elementtree_1.SubElement)(holder, isCheck ? "City" : "CardHolderCity").append((0, elementtree_1.CData)((0, InputValidation_1.validateInput)("portico", "city", builder.billingAddress.city)));
                (0, elementtree_1.SubElement)(holder, isCheck ? "State" : "CardHolderState").append((0, elementtree_1.CData)((0, InputValidation_1.validateInput)("portico", "province", builder.billingAddress.province || builder.billingAddress.state)));
                (0, elementtree_1.SubElement)(holder, isCheck ? "Zip" : "CardHolderZip").append((0, elementtree_1.CData)((0, InputValidation_1.validateInput)("portico", "postalCode", builder.billingAddress.postalCode)));
            }
            if (isCheck) {
                const check = builder.paymentMethod;
                (0, elementtree_1.SubElement)(holder, "CheckName").append((0, elementtree_1.CData)(check.checkName || check.checkHolderName));
                (0, elementtree_1.SubElement)(holder, "PhoneNumber").append((0, elementtree_1.CData)((0, InputValidation_1.validateInput)("portico", "phoneNumber", check.phoneNumber)));
                (0, elementtree_1.SubElement)(holder, "DLNumber").append((0, elementtree_1.CData)(check.driversLicenseNumber));
                (0, elementtree_1.SubElement)(holder, "DLState").append((0, elementtree_1.CData)(check.driversLicenseState));
                if (check.ssnLast4 || check.birthYear) {
                    const identity = (0, elementtree_1.SubElement)(holder, "IdentityInfo");
                    (0, elementtree_1.SubElement)(identity, "SSNL4").append((0, elementtree_1.CData)(check.ssnLast4));
                    (0, elementtree_1.SubElement)(identity, "DOBYear").append((0, elementtree_1.CData)(check.birthYear));
                }
            }
        }
        const { hasToken, tokenValue } = this.hasToken(builder.paymentMethod);
        let cardData;
        if (builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.Debit ||
            builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.ACH) {
            cardData = block1;
        }
        else {
            cardData = (0, elementtree_1.Element)("CardData");
        }
        if (builder.paymentMethod.isCardData) {
            const card = builder.paymentMethod;
            const manualEntry = (0, elementtree_1.SubElement)(cardData, hasToken ? "TokenData" : "ManualEntry");
            if (this.shouldIncludeCredentialOnFile(builder) &&
                (builder.cardBrandTransactionId || builder.transactionInitiator)) {
                block1.append(this.hydrateCredentialOnFile(builder));
            }
            (0, elementtree_1.SubElement)(manualEntry, hasToken ? "TokenValue" : "CardNbr").append((0, elementtree_1.CData)(tokenValue || card.number));
            if (card.expMonth) {
                (0, elementtree_1.SubElement)(manualEntry, "ExpMonth").append((0, elementtree_1.CData)(card.expMonth.toString()));
            }
            if (card.expYear) {
                (0, elementtree_1.SubElement)(manualEntry, "ExpYear").append((0, elementtree_1.CData)(card.expYear.toString()));
            }
            if (card.cvn) {
                (0, elementtree_1.SubElement)(manualEntry, "CVV2").append((0, elementtree_1.CData)(card.cvn));
            }
            (0, elementtree_1.SubElement)(manualEntry, "ReaderPresent").append((0, elementtree_1.CData)(card.readerPresent ? "Y" : "N"));
            (0, elementtree_1.SubElement)(manualEntry, "CardPresent").append((0, elementtree_1.CData)(card.cardPresent ? "Y" : "N"));
            block1.append(cardData);
            if (card instanceof __1.CreditCardData) {
                const creditCardData = card;
                const secureEcom = creditCardData.threeDSecure;
                if (secureEcom) {
                    // 3d Secure Element
                    if (secureEcom.eci &&
                        !this.isAppleOrGooglePay(secureEcom.paymentDataSource)) {
                        const secure3D = (0, elementtree_1.SubElement)(block1, "Secure3D");
                        (0, elementtree_1.SubElement)(secure3D, "Version").text = threeDSecureNumericVersion(secureEcom.version);
                        (0, elementtree_1.SubElement)(secure3D, "AuthenticationValue").append((0, elementtree_1.CData)(secureEcom.cavv));
                        (0, elementtree_1.SubElement)(secure3D, "ECI").append((0, elementtree_1.CData)(secureEcom.eci.toFixed(0)));
                        (0, elementtree_1.SubElement)(secure3D, "DirectoryServerTxnId").append((0, elementtree_1.CData)(secureEcom.xid));
                    }
                    // WalletData Element
                    if (this.isAppleOrGooglePay(secureEcom.paymentDataSource)) {
                        const walletData = (0, elementtree_1.SubElement)(block1, "WalletData");
                        (0, elementtree_1.SubElement)(walletData, "PaymentSource").append((0, elementtree_1.CData)(secureEcom.paymentDataSource));
                        (0, elementtree_1.SubElement)(walletData, "Cryptogram").append((0, elementtree_1.CData)(secureEcom.cavv));
                        (0, elementtree_1.SubElement)(walletData, "ECI").append((0, elementtree_1.CData)(secureEcom.eci.toFixed()));
                    }
                }
                //  WalletData Element
                if ((creditCardData.mobileType == __1.MobilePaymentMethodType.APPLEPAY ||
                    creditCardData.mobileType == __1.MobilePaymentMethodType.GOOGLEPAY) &&
                    typeof creditCardData.paymentSource != "undefined" &&
                    this.isAppleOrGooglePay(creditCardData.paymentSource)) {
                    const walletData = (0, elementtree_1.SubElement)(block1, "WalletData");
                    (0, elementtree_1.SubElement)(walletData, "PaymentSource").append((0, elementtree_1.CData)(creditCardData.paymentSource.trim()));
                    if (typeof creditCardData.mobileType != "undefined") {
                        (0, elementtree_1.SubElement)(walletData, "DigitalPaymentToken").append((0, elementtree_1.CData)(creditCardData.token));
                        block1.remove(cardData);
                    }
                }
            }
            if (builder.transactionModifier === __1.TransactionModifier.Recurring) {
                const recurring = (0, elementtree_1.SubElement)(block1, "RecurringData");
                (0, elementtree_1.SubElement)(recurring, "ScheduleID").append((0, elementtree_1.CData)(builder.scheduleId));
                (0, elementtree_1.SubElement)(recurring, "OneTime").append((0, elementtree_1.CData)(builder.oneTimePayment ? "Y" : "N"));
            }
        }
        else if (builder.paymentMethod.isTrackData) {
            const track = builder.paymentMethod;
            const trackData = (0, elementtree_1.SubElement)(cardData, hasToken ? "TokenData" : "TrackData");
            if (!hasToken) {
                trackData.append((0, elementtree_1.CData)(track.value));
                if (builder.paymentMethod.paymentMethodType !== __1.PaymentMethodType.Debit) {
                    trackData.set("method", track.entryMethod === __1.EntryMethod.Swipe ? "swipe" : "proximity");
                    block1.append(cardData);
                }
            }
            else if (tokenValue) {
                (0, elementtree_1.SubElement)(trackData, "TokenValue").append((0, elementtree_1.CData)(tokenValue));
            }
        }
        else if (builder.paymentMethod instanceof __1.GiftCard) {
            const card = builder.paymentMethod;
            if (builder.currency) {
                (0, elementtree_1.SubElement)(block1, "Currency").append((0, elementtree_1.CData)(builder.currency.toUpperCase()));
            }
            // if it's replace, add the new card, and change the card data name to be old card data
            if (builder.transactionType === __1.TransactionType.Replace) {
                const newCardData = (0, elementtree_1.SubElement)(block1, "NewCardData");
                (0, elementtree_1.SubElement)(newCardData, builder.replacementCard.valueType).append((0, elementtree_1.CData)(builder.replacementCard.value));
                (0, elementtree_1.SubElement)(newCardData, "PIN").append((0, elementtree_1.CData)(builder.replacementCard.pin));
                cardData = (0, elementtree_1.Element)("OldCardData");
            }
            (0, elementtree_1.SubElement)(cardData, card.valueType).append((0, elementtree_1.CData)(card.value));
            if (card.pin) {
                (0, elementtree_1.SubElement)(cardData, "PIN").append((0, elementtree_1.CData)(card.pin));
            }
            if (builder.aliasAction !== __1.AliasAction.Create) {
                block1.append(cardData);
            }
        }
        else if (builder.paymentMethod instanceof __1.ECheck) {
            const check = builder.paymentMethod;
            (0, elementtree_1.SubElement)(block1, "CheckAction").append((0, elementtree_1.CData)("SALE"));
            if (!hasToken) {
                const accountInfo = (0, elementtree_1.SubElement)(block1, "AccountInfo");
                (0, elementtree_1.SubElement)(accountInfo, "RoutingNumber").append((0, elementtree_1.CData)(check.routingNumber));
                (0, elementtree_1.SubElement)(accountInfo, "AccountNumber").append((0, elementtree_1.CData)(check.accountNumber));
                (0, elementtree_1.SubElement)(accountInfo, "CheckNumber").append((0, elementtree_1.CData)(check.checkNumber));
                (0, elementtree_1.SubElement)(accountInfo, "MICRData").append((0, elementtree_1.CData)(check.micrNumber));
                (0, elementtree_1.SubElement)(accountInfo, "AccountType").append((0, elementtree_1.CData)(check.accountType.toString()));
            }
            else if (tokenValue) {
                (0, elementtree_1.SubElement)(block1, "TokenValue").append((0, elementtree_1.CData)(tokenValue));
            }
            (0, elementtree_1.SubElement)(block1, "DataEntryMode").append((0, elementtree_1.CData)(check.entryMode.toString().toUpperCase()));
            (0, elementtree_1.SubElement)(block1, "CheckType").append((0, elementtree_1.CData)(check.checkType.toString()));
            (0, elementtree_1.SubElement)(block1, "SECCode").append((0, elementtree_1.CData)(check.secCode.toString()));
            const verify = (0, elementtree_1.SubElement)(block1, "VerifyInfo");
            (0, elementtree_1.SubElement)(verify, "CheckVerify").append((0, elementtree_1.CData)(check.checkVerify ? "Y" : "N"));
            (0, elementtree_1.SubElement)(verify, "ACHVerify").append((0, elementtree_1.CData)(check.achVerify ? "Y" : "N"));
        }
        if (builder.paymentMethod instanceof __1.TransactionReference) {
            const reference = builder.paymentMethod;
            if (reference.transactionId) {
                (0, elementtree_1.SubElement)(block1, "GatewayTxnId").append((0, elementtree_1.CData)(reference.transactionId));
            }
            if (reference.clientTransactionId) {
                (0, elementtree_1.SubElement)(block1, "ClientTxnId").append((0, elementtree_1.CData)(reference.clientTransactionId));
            }
        }
        if (builder.paymentMethod instanceof __1.RecurringPaymentMethod) {
            const method = builder.paymentMethod;
            if (method.paymentType === "ACH") {
                if (allowDuplicates) {
                    block1.remove(allowDuplicates);
                }
                (0, elementtree_1.SubElement)(block1, "CheckAction").append((0, elementtree_1.CData)("SALE"));
            }
            (0, elementtree_1.SubElement)(block1, "PaymentMethodKey").append((0, elementtree_1.CData)(method.key));
            if (method.paymentMethod &&
                method.paymentMethod instanceof __1.CreditCardData) {
                const card = method.paymentMethod;
                const data = (0, elementtree_1.SubElement)(block1, "PaymentMethodKeyData");
                (0, elementtree_1.SubElement)(data, "ExpMonth").append((0, elementtree_1.CData)(card.expMonth));
                (0, elementtree_1.SubElement)(data, "ExpYear").append((0, elementtree_1.CData)(card.expYear));
                (0, elementtree_1.SubElement)(data, "CVV2").append((0, elementtree_1.CData)(card.cvn));
                if (this.shouldIncludeCredentialOnFile(builder) &&
                    (builder.cardBrandTransactionId || builder.transactionInitiator)) {
                    block1.append(this.hydrateCredentialOnFile(builder));
                }
            }
            const recurring = (0, elementtree_1.SubElement)(block1, "RecurringData");
            (0, elementtree_1.SubElement)(recurring, "ScheduleID").append((0, elementtree_1.CData)(builder.scheduleId));
            (0, elementtree_1.SubElement)(recurring, "OneTime").append((0, elementtree_1.CData)(builder.oneTimePayment ? "Y" : "N"));
        }
        if (builder.paymentMethod.isPinProtected &&
            builder.transactionType !== __1.TransactionType.Reversal) {
            (0, elementtree_1.SubElement)(block1, "PinBlock").append((0, elementtree_1.CData)(builder.paymentMethod.pinBlock));
        }
        if (builder.paymentMethod.isEncryptable) {
            const encryptionData = builder.paymentMethod
                .encryptionData;
            if (encryptionData) {
                const enc = (0, elementtree_1.SubElement)(cardData, "EncryptionData");
                if (encryptionData.version) {
                    (0, elementtree_1.SubElement)(enc, "Version").append((0, elementtree_1.CData)(encryptionData.version));
                }
                if (encryptionData.trackNumber) {
                    (0, elementtree_1.SubElement)(enc, "EncryptedTrackNumber").append((0, elementtree_1.CData)(encryptionData.trackNumber));
                }
                if (encryptionData.ktb) {
                    (0, elementtree_1.SubElement)(enc, "KTB").append((0, elementtree_1.CData)(encryptionData.ktb));
                }
                if (encryptionData.ksn) {
                    (0, elementtree_1.SubElement)(enc, "KSN").append((0, elementtree_1.CData)(encryptionData.ksn));
                }
            }
        }
        if (builder.paymentMethod.isTokenizable &&
            builder.paymentMethod.paymentMethodType !== __1.PaymentMethodType.ACH) {
            (0, elementtree_1.SubElement)(cardData, "TokenRequest").append((0, elementtree_1.CData)(builder.requestMultiUseToken ? "Y" : "N"));
            if (builder.requestUniqueToken) {
                const tokenParameters = (0, elementtree_1.SubElement)(cardData, "TokenParameters");
                const tokenMapping = (0, elementtree_1.SubElement)(tokenParameters, "Mapping");
                tokenMapping.append((0, elementtree_1.CData)("UNIQUE"));
            }
        }
        if (builder.paymentMethod.isBalanceable && builder.balanceInquiryType) {
            (0, elementtree_1.SubElement)(block1, "BalanceInquiryType").append((0, elementtree_1.CData)(builder.balanceInquiryType.toString()));
        }
        if (builder.level2Request) {
            (0, elementtree_1.SubElement)(block1, "CPCReq").append((0, elementtree_1.CData)("Y"));
        }
        if (builder.customerId || builder.description || builder.invoiceNumber) {
            const fields = (0, elementtree_1.SubElement)(block1, "AdditionalTxnFields");
            (0, elementtree_1.SubElement)(fields, "CustomerID").append((0, elementtree_1.CData)(builder.customerId));
            (0, elementtree_1.SubElement)(fields, "Description").append((0, elementtree_1.CData)(builder.description));
            (0, elementtree_1.SubElement)(fields, "InvoiceNbr").append((0, elementtree_1.CData)(builder.invoiceNumber));
        }
        if (builder.ecommerceInfo) {
            if (builder.ecommerceInfo.channel) {
                (0, elementtree_1.SubElement)(block1, "Ecommerce").append((0, elementtree_1.CData)(builder.ecommerceInfo.channel.toString()));
            }
            if (builder.invoiceNumber || builder.ecommerceInfo.shipMonth) {
                const direct = (0, elementtree_1.SubElement)(block1, "DirectMktData");
                (0, elementtree_1.SubElement)(direct, "DirectMktInvoiceNbr").append((0, elementtree_1.CData)(builder.invoiceNumber));
                (0, elementtree_1.SubElement)(direct, "DirectMktShipDay").append((0, elementtree_1.CData)(builder.ecommerceInfo.shipDay));
                (0, elementtree_1.SubElement)(direct, "DirectMktShipMonth").append((0, elementtree_1.CData)(builder.ecommerceInfo.shipMonth));
            }
            if (builder.ecommerceInfo.cavv ||
                builder.ecommerceInfo.eci ||
                builder.ecommerceInfo.xid) {
                const secure = (0, elementtree_1.SubElement)(block1, "SecureECommerce");
                (0, elementtree_1.SubElement)(secure, "PaymentDataSource").append((0, elementtree_1.CData)(builder.ecommerceInfo.paymentDataSource));
                (0, elementtree_1.SubElement)(secure, "TypeOfPaymentData").append((0, elementtree_1.CData)(builder.ecommerceInfo.paymentDataType));
                (0, elementtree_1.SubElement)(secure, "PaymentData").append((0, elementtree_1.CData)(builder.ecommerceInfo.cavv));
                (0, elementtree_1.SubElement)(secure, "ECommerceIndicator").append((0, elementtree_1.CData)(builder.ecommerceInfo.eci));
                (0, elementtree_1.SubElement)(secure, "XID").append((0, elementtree_1.CData)(builder.ecommerceInfo.xid));
            }
        }
        if (builder.dynamicDescriptor) {
            (0, elementtree_1.SubElement)(block1, "TxnDescriptor").append((0, elementtree_1.CData)(builder.dynamicDescriptor));
        }
        return this.doTransaction(this.buildEnvelope(transaction, builder.clientTransactionId)).then((response) => this.mapResponse(response, builder));
    }
    serializeRequest() {
        throw new __1.UnsupportedTransactionError("Portico does not support hosted payments.");
    }
    manageTransaction(builder) {
        // build request
        const transaction = (0, elementtree_1.Element)(this.mapRequestType(builder));
        if (builder.transactionType !== __1.TransactionType.BatchClose) {
            let root;
            if (builder.transactionType === __1.TransactionType.Reversal ||
                builder.transactionType === __1.TransactionType.Refund ||
                builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.Gift ||
                builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.ACH ||
                builder.transactionModifier === __1.TransactionModifier.Incremental) {
                root = new elementtree_1.Element("Block1");
            }
            else {
                root = transaction;
            }
            // amount
            if (builder.amount) {
                (0, elementtree_1.SubElement)(root, "Amt").append((0, elementtree_1.CData)(builder.amount.toString()));
            }
            // auth amount
            if (builder.authAmount) {
                (0, elementtree_1.SubElement)(root, "AuthAmt").append((0, elementtree_1.CData)(builder.authAmount.toString()));
            }
            // gratuity
            if (builder.gratuity) {
                (0, elementtree_1.SubElement)(root, "GratuityAmtInfo").append((0, elementtree_1.CData)(builder.gratuity.toString()));
            }
            if (builder.clientTransactionId) {
                (0, elementtree_1.SubElement)(root, "ClientTxnId").append((0, elementtree_1.CData)(builder.clientTransactionId));
            }
            // transaction ID
            if (builder.paymentMethod &&
                builder.paymentMethod.transactionId) {
                const ref = builder.paymentMethod;
                (0, elementtree_1.SubElement)(root, "GatewayTxnId").append((0, elementtree_1.CData)(ref.transactionId));
            }
            // level II or III
            if (builder.commercialData) {
                const modifier = builder.transactionModifier;
                const cd = builder.commercialData;
                if (modifier === __1.TransactionModifier.LevelII ||
                    modifier === __1.TransactionModifier.LevelIII) {
                    const cpc = (0, elementtree_1.SubElement)(root, "CPCData");
                    if (cd.poNumber !== undefined) {
                        (0, elementtree_1.SubElement)(cpc, "CardHolderPONbr").append((0, elementtree_1.CData)(cd.poNumber));
                    }
                    if (cd.taxType !== undefined) {
                        (0, elementtree_1.SubElement)(cpc, "TaxType").append((0, elementtree_1.CData)(this.hydrateTaxType(cd.taxType)));
                    }
                    if (cd.taxAmount !== undefined) {
                        (0, elementtree_1.SubElement)(cpc, "TaxAmt").append((0, elementtree_1.CData)(cd.taxAmount.toString()));
                    }
                }
                const paymentType = builder.paymentMethod?.paymentMethodType;
                if (modifier === __1.TransactionModifier.LevelIII &&
                    paymentType &&
                    paymentType === __1.PaymentMethodType.Credit) {
                    const cdc = (0, elementtree_1.SubElement)(root, "CorporateData");
                    const isVisa = builder.cardType === "Visa";
                    const data = (0, elementtree_1.SubElement)(cdc, isVisa ? "Visa" : "MC");
                    if (cd.lineItems !== undefined) {
                        buildLineItems(data, isVisa, cd.lineItems);
                    }
                    if (isVisa) {
                        if (cd.summaryCommodityCode !== undefined) {
                            (0, elementtree_1.SubElement)(data, "SummaryCommodityCode").append((0, elementtree_1.CData)(cd.summaryCommodityCode));
                        }
                        if (cd.discountAmount !== undefined) {
                            (0, elementtree_1.SubElement)(data, "DiscountAmt").append((0, elementtree_1.CData)(cd.discountAmount.toString()));
                        }
                        if (cd.freightAmount !== undefined) {
                            (0, elementtree_1.SubElement)(data, "FreightAmt").append((0, elementtree_1.CData)(cd.freightAmount.toString()));
                        }
                        if (cd.dutyAmount !== undefined) {
                            (0, elementtree_1.SubElement)(data, "DutyAmt").append((0, elementtree_1.CData)(cd.dutyAmount.toString()));
                        }
                        if (cd.destinationPostalCode !== undefined) {
                            (0, elementtree_1.SubElement)(data, "DestinationPostalZipCode").append((0, elementtree_1.CData)(cd.destinationPostalCode));
                        }
                        if (cd.originPostalCode !== undefined) {
                            (0, elementtree_1.SubElement)(data, "ShipFromPostalZipCode").append((0, elementtree_1.CData)(cd.originPostalCode));
                        }
                        if (cd.destinationCountryCode !== undefined) {
                            (0, elementtree_1.SubElement)(data, "DestinationCountryCode").append((0, elementtree_1.CData)(cd.destinationCountryCode));
                        }
                        if (cd.customerReferenceId !== undefined) {
                            (0, elementtree_1.SubElement)(data, "InvoiceRefNbr").append((0, elementtree_1.CData)(cd.customerReferenceId));
                        }
                        const taxAmount = cd.taxAmount ? cd.taxAmount.toString() : "0";
                        if (cd.additionalTaxDetails?.taxAmount !== undefined ||
                            cd.taxAmount !== undefined) {
                            (0, elementtree_1.SubElement)(data, "VATTaxAmtFreight").append((0, elementtree_1.CData)(cd.additionalTaxDetails?.taxAmount
                                ? cd.additionalTaxDetails.taxAmount.toString()
                                : taxAmount));
                        }
                        if (cd.orderDate instanceof Date) {
                            const formattedDate = cd.orderDate.toISOString().slice(0, 19);
                            (0, elementtree_1.SubElement)(data, "OrderDate").append((0, elementtree_1.CData)(formattedDate));
                        }
                        if (cd.additionalTaxDetails?.taxRate !== undefined) {
                            (0, elementtree_1.SubElement)(data, "VATTaxRateFreight").append((0, elementtree_1.CData)(cd.additionalTaxDetails.taxRate.toString()));
                        }
                    }
                }
            }
            else if (
            // level II only
            builder.transactionType === __1.TransactionType.Edit &&
                builder.transactionModifier === __1.TransactionModifier.LevelII) {
                const cpc = (0, elementtree_1.SubElement)(root, "CPCData");
                if (builder.poNumber) {
                    (0, elementtree_1.SubElement)(cpc, "CardHolderPONbr").append((0, elementtree_1.CData)(builder.poNumber));
                }
                if (builder.taxType) {
                    (0, elementtree_1.SubElement)(cpc, "TaxType").append((0, elementtree_1.CData)(this.hydrateTaxType(builder.taxType)));
                }
                if (builder.taxAmount) {
                    (0, elementtree_1.SubElement)(cpc, "TaxAmt").append((0, elementtree_1.CData)(builder.taxAmount.toString()));
                }
            }
            // Token Management
            if (builder.paymentMethod &&
                builder.paymentMethod.isTokenizable &&
                builder.transactionType === __1.TransactionType.TokenUpdate) {
                const tokenActions = (0, elementtree_1.SubElement)(root, "TokenActions");
                (0, elementtree_1.SubElement)(root, "TokenValue").append((0, elementtree_1.CData)(builder.paymentMethod.token));
                const set = (0, elementtree_1.SubElement)(tokenActions, "Set");
                const expMonth = (0, elementtree_1.SubElement)(set, "Attribute");
                (0, elementtree_1.SubElement)(expMonth, "Name").append((0, elementtree_1.CData)("expmonth"));
                (0, elementtree_1.SubElement)(expMonth, "Value").append((0, elementtree_1.CData)(builder.paymentMethod.expMonth));
                const expYear = (0, elementtree_1.SubElement)(set, "Attribute");
                (0, elementtree_1.SubElement)(expYear, "Name").append((0, elementtree_1.CData)("expyear"));
                (0, elementtree_1.SubElement)(expYear, "Value").append((0, elementtree_1.CData)(builder.paymentMethod.expYear));
            }
            else if (builder.paymentMethod &&
                builder.paymentMethod.isTokenizable &&
                builder.transactionType === __1.TransactionType.TokenDelete) {
                const tokenActions = (0, elementtree_1.SubElement)(root, "TokenActions");
                (0, elementtree_1.SubElement)(root, "TokenValue").append((0, elementtree_1.CData)(builder.paymentMethod.token));
                (0, elementtree_1.SubElement)(tokenActions, "Delete");
            }
            if (builder.transactionType === __1.TransactionType.Reversal ||
                builder.transactionType === __1.TransactionType.Refund ||
                builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.Gift ||
                builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.ACH ||
                builder.transactionModifier === __1.TransactionModifier.Incremental) {
                transaction.append(root);
            }
        }
        return this.doTransaction(this.buildEnvelope(transaction, builder.clientTransactionId)).then((response) => this.mapResponse(response, builder));
    }
    processReport(builder) {
        const transaction = (0, elementtree_1.Element)(this.mapReportRequestType(builder));
        if (builder.timeZoneConversion) {
            (0, elementtree_1.SubElement)(transaction, "TzConversion").append((0, elementtree_1.CData)(builder.timeZoneConversion.toString()));
        }
        if (builder instanceof __1.TransactionReportBuilder) {
            const trb = builder;
            if (trb.deviceId) {
                (0, elementtree_1.SubElement)(transaction, "DeviceId").append((0, elementtree_1.CData)(trb.deviceId));
            }
            if (trb.startDate) {
                (0, elementtree_1.SubElement)(transaction, "RptStartUtcDT").append((0, elementtree_1.CData)(trb.startDate.toISOString()));
            }
            if (trb.endDate) {
                (0, elementtree_1.SubElement)(transaction, "RptEndUtcDT").append((0, elementtree_1.CData)(trb.endDate.toISOString()));
            }
            if (trb.transactionId) {
                (0, elementtree_1.SubElement)(transaction, "TxnId").append((0, elementtree_1.CData)(trb.transactionId));
            }
            if (trb.searchCriteria) {
                const criteriaNode = (0, elementtree_1.Element)("Criteria");
                for (const property in trb.searchCriteria) {
                    (0, elementtree_1.SubElement)(criteriaNode, property).append((0, elementtree_1.CData)(trb.searchCriteria[property]));
                }
                transaction.append(criteriaNode);
            }
        }
        return this.doTransaction(this.buildEnvelope(transaction)).then((response) => this.mapReportResponse(response, builder));
    }
    buildEnvelope(transaction, clientTransactionId) {
        const envelope = (0, elementtree_1.Element)("soap:Envelope", {
            "xmlns:soap": "http://schemas.xmlsoap.org/soap/envelope/",
        });
        const body = (0, elementtree_1.SubElement)(envelope, "soap:Body");
        const request = (0, elementtree_1.SubElement)(body, "PosRequest", {
            xmlns: PorticoConnector.XmlNamespace,
        });
        const version1 = (0, elementtree_1.SubElement)(request, "Ver1.0");
        // header
        const header = (0, elementtree_1.SubElement)(version1, "Header");
        if (this.secretApiKey) {
            (0, elementtree_1.SubElement)(header, "SecretAPIKey").append((0, elementtree_1.CData)(this.secretApiKey));
        }
        if (this.siteId) {
            (0, elementtree_1.SubElement)(header, "SiteId").append((0, elementtree_1.CData)(this.siteId));
        }
        if (this.licenseId) {
            (0, elementtree_1.SubElement)(header, "LicenseId").append((0, elementtree_1.CData)(this.licenseId));
        }
        if (this.deviceId) {
            (0, elementtree_1.SubElement)(header, "DeviceId").append((0, elementtree_1.CData)(this.deviceId));
        }
        if (this.username) {
            (0, elementtree_1.SubElement)(header, "UserName").append((0, elementtree_1.CData)(this.username));
        }
        if (this.password) {
            (0, elementtree_1.SubElement)(header, "Password").append((0, elementtree_1.CData)(this.password));
        }
        if (this.developerId) {
            (0, elementtree_1.SubElement)(header, "DeveloperID").append((0, elementtree_1.CData)(this.developerId));
        }
        if (this.versionNumber) {
            (0, elementtree_1.SubElement)(header, "VersionNbr").append((0, elementtree_1.CData)(this.versionNumber));
        }
        if (clientTransactionId) {
            (0, elementtree_1.SubElement)(header, "ClientTxnId").append((0, elementtree_1.CData)(clientTransactionId));
        }
        if (this.sdkNameVersion) {
            (0, elementtree_1.SubElement)(header, "SDKNameVersion").append((0, elementtree_1.CData)(this.sdkNameVersion));
        }
        else {
            (0, elementtree_1.SubElement)(header, "SDKNameVersion").append((0, elementtree_1.CData)("nodejs-version:" + process.env.npm_package_version));
        }
        // transaction
        (0, elementtree_1.SubElement)(version1, "Transaction").append(transaction);
        return new elementtree_1.ElementTree(envelope).write();
    }
    mapRequestType(builder) {
        switch (builder.transactionType) {
            case __1.TransactionType.BatchClose:
                return "BatchClose";
            case __1.TransactionType.Decline:
                if (builder.transactionModifier === __1.TransactionModifier.ChipDecline) {
                    return "ChipCardDecline";
                }
                else if (builder.transactionModifier === __1.TransactionModifier.FraudDecline) {
                    return "OverrideFraudDecline";
                }
                throw new __1.UnsupportedTransactionError();
            case __1.TransactionType.Verify:
                if (builder.transactionModifier === __1.TransactionModifier.EncryptedMobile) {
                    throw new __1.UnsupportedTransactionError();
                }
                return "CreditAccountVerify";
            case __1.TransactionType.Capture:
                return "CreditAddToBatch";
            case __1.TransactionType.Auth:
                if (builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.Credit) {
                    if (builder.transactionModifier === __1.TransactionModifier.Additional) {
                        return "CreditAdditionalAuth";
                    }
                    else if (builder.transactionModifier === __1.TransactionModifier.Incremental) {
                        return "CreditIncrementalAuth";
                    }
                    else if (
                    // @ts-ignore
                    builder.paymentMethod.paymentMethodType ===
                        __1.PaymentMethodType.Recurring) {
                        return "RecurringBillingAuth";
                    }
                    else if (builder.transactionModifier === __1.TransactionModifier.EncryptedMobile) {
                        throw new __1.UnsupportedTransactionError();
                    }
                    else if (builder.transactionModifier === __1.TransactionModifier.Offline) {
                        return "CreditOfflineAuth";
                    }
                    return "CreditAuth";
                }
                else if (builder.paymentMethod.paymentMethodType ===
                    __1.PaymentMethodType.Recurring) {
                    return "RecurringBillingAuth";
                }
                throw new __1.UnsupportedTransactionError();
            case __1.TransactionType.Sale:
                if (builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.Credit) {
                    if (builder.transactionModifier === __1.TransactionModifier.Offline) {
                        return "CreditOfflineSale";
                    }
                    else if (builder.transactionModifier === __1.TransactionModifier.Recurring) {
                        return "RecurringBilling";
                    }
                    else if (builder.transactionModifier === __1.TransactionModifier.EncryptedMobile) {
                        throw new __1.UnsupportedTransactionError();
                    }
                    else {
                        return "CreditSale";
                    }
                }
                else if (builder.paymentMethod.paymentMethodType ===
                    __1.PaymentMethodType.Recurring) {
                    if (builder.paymentMethod.paymentType === "ACH") {
                        return "CheckSale";
                    }
                    return "RecurringBilling";
                }
                else if (builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.Debit) {
                    return "DebitSale";
                }
                else if (builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.Cash) {
                    return "CashSale";
                }
                else if (builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.ACH) {
                    return "CheckSale";
                }
                else if (builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.EBT) {
                    if (builder.transactionModifier === __1.TransactionModifier.CashBack) {
                        return "EBTCashBackPurchase";
                    }
                    else if (builder.transactionModifier === __1.TransactionModifier.Voucher) {
                        return "EBTVoucherPurchase";
                    }
                    else {
                        return "EBTFSPurchase";
                    }
                }
                else if (builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.Gift) {
                    return "GiftCardSale";
                }
                throw new __1.UnsupportedTransactionError();
            case __1.TransactionType.Refund:
                if (builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.Credit) {
                    return "CreditReturn";
                }
                else if (builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.Debit) {
                    if (builder.paymentMethod instanceof __1.TransactionReference) {
                        throw new __1.UnsupportedTransactionError();
                    }
                    return "DebitReturn";
                }
                else if (builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.Cash) {
                    return "CashReturn";
                }
                else if (builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.EBT) {
                    if (builder.paymentMethod instanceof __1.TransactionReference) {
                        throw new __1.UnsupportedTransactionError();
                    }
                    return "EBTFSReturn";
                }
                throw new __1.UnsupportedTransactionError();
            case __1.TransactionType.Reversal:
                if (builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.Credit) {
                    return "CreditReversal";
                }
                else if (builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.Debit) {
                    return "DebitReversal";
                }
                else if (builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.Gift) {
                    return "GiftCardReversal";
                }
                throw new __1.UnsupportedTransactionError();
            case __1.TransactionType.Edit:
                if (builder.transactionModifier === __1.TransactionModifier.LevelII ||
                    builder.transactionModifier === __1.TransactionModifier.LevelIII) {
                    return "CreditCPCEdit";
                }
                return "CreditTxnEdit";
            case __1.TransactionType.Void:
                if (builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.Credit) {
                    return "CreditVoid";
                }
                else if (builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.ACH) {
                    return "CheckVoid";
                }
                else if (builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.Gift) {
                    return "GiftCardVoid";
                }
                throw new __1.UnsupportedTransactionError();
            case __1.TransactionType.AddValue:
                if (builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.Credit) {
                    return "PrePaidAddValue";
                }
                else if (builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.Debit) {
                    return "DebitAddValue";
                }
                else if (builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.Gift) {
                    return "GiftCardAddValue";
                }
                throw new __1.UnsupportedTransactionError();
            case __1.TransactionType.Balance:
                if (builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.Credit) {
                    return "PrePaidBalanceInquiry";
                }
                else if (builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.EBT) {
                    return "EBTBalanceInquiry";
                }
                else if (builder.paymentMethod.paymentMethodType === __1.PaymentMethodType.Gift) {
                    return "GiftCardBalance";
                }
                throw new __1.UnsupportedTransactionError();
            case __1.TransactionType.BenefitWithDrawal:
                return "EBTCashBenefitWithdrawal";
            case __1.TransactionType.Activate:
                return "GiftCardActivate";
            case __1.TransactionType.Alias:
                return "GiftCardAlias";
            case __1.TransactionType.Deactivate:
                return "GiftCardDeactivate";
            case __1.TransactionType.Replace:
                return "GiftCardReplace";
            case __1.TransactionType.Reward:
                return "GiftCardReward";
            case __1.TransactionType.Tokenize:
                return "Tokenize";
            case __1.TransactionType.TokenUpdate:
            case __1.TransactionType.TokenDelete:
                return "ManageTokens";
            default:
                break;
        }
        throw new __1.NotImplementedError();
    }
    mapReportRequestType(builder) {
        switch (builder.reportType) {
            case __1.ReportType.Activity:
                return "ReportActivity";
            case __1.ReportType.TransactionDetail:
                return "ReportTxnDetail";
            case __1.ReportType.FindTransactions:
                return "FindTransactions";
            default:
                throw new __1.UnsupportedTransactionError();
        }
    }
    mapResponse(rawResponse, builder) {
        const result = new __1.Transaction();
        const root = (0, elementtree_1.XML)(rawResponse).find(".//PosResponse");
        const acceptedCodes = ["00", "0", "85", "10"];
        const gatewayRspCode = this.normalizeResponse(root.findtext(".//GatewayRspCode"));
        const gatewayRspText = root.findtext(".//GatewayRspMsg");
        if (acceptedCodes.indexOf(gatewayRspCode) === -1) {
            throw new __1.GatewayError(`Unexpected Gateway Response: ${gatewayRspCode} - ${gatewayRspText}`);
        }
        result.responseCode = root.findtext(".//RspCode")
            ? this.normalizeResponse(root.findtext(".//RspCode"))
            : gatewayRspCode;
        const rspMsg = root.findtext(".//RspMessage")
            ? root.findtext(".//RspMessage")
            : root.findtext(".//RspText");
        result.responseMessage = rspMsg || gatewayRspText;
        result.authorizedAmount = root.findtext(".//AuthAmt");
        result.availableBalance = root.findtext(".//AvailableBalance");
        result.avsResponseCode = root.findtext(".//AVSRsltCode");
        result.avsResponseMessage = root.findtext(".//AVSRsltText");
        result.balanceAmount = root.findtext(".//BalanceAmt");
        result.cardType = root.findtext(".//CardType");
        result.cardLast4 = root.findtext(".//TokenPANLast4");
        result.cavvResponseCode = root.findtext(".//CAVVResultCode");
        result.commercialIndicator = root.findtext(".//CPCInd");
        result.cvnResponseCode = root.findtext(".//CVVRsltCode");
        result.cvnResponseMessage = root.findtext(".//CVVRsltText");
        result.pointsBalanceAmount = root.findtext(".//PointsBalanceAmt");
        result.recurringDataCode = root.findtext(".//RecurringDataCode");
        result.referenceNumber = root.findtext(".//RefNbr");
        result.transactionDescriptor = root.findtext(".//TxnDescriptor");
        result.cardBrandTransactionId = root.findtext(".//CardBrandTxnId");
        if (builder.paymentMethod) {
            result.transactionReference = new __1.TransactionReference(root.findtext(".//GatewayTxnId"));
            result.transactionReference.paymentMethodType =
                builder.paymentMethod.paymentMethodType;
        }
        if (root.findtext(".//AuthCode")) {
            result.transactionReference =
                result.transactionReference || new __1.TransactionReference();
            result.transactionReference.authCode = root.findtext(".//AuthCode");
        }
        if (root.find(".//TokenData") &&
            root.find(".//TokenData").findtext(".//TokenValue")) {
            const tokenData = root.find(".//TokenData");
            result.token = tokenData.findtext(".//TokenValue");
        }
        if (root.find(".//CardData")) {
            const cardData = root.find(".//CardData");
            result.giftCard = new __1.GiftCard();
            result.giftCard.number = cardData.findtext(".//CardNbr");
            result.giftCard.alias = cardData.findtext(".//Alias");
            result.giftCard.pin = cardData.findtext(".//PIN");
        }
        if (root.find(".//BatchId")) {
            result.batchId = root.findtext(".//BatchId");
            result.batchSeqNbr = root.findtext(".//BatchSeqNbr");
        }
        return result;
    }
    mapReportResponse(rawResponse, builder) {
        // todo: handle non-200 responses
        const posResponse = (0, elementtree_1.XML)(rawResponse).find(".//PosResponse");
        const doc = posResponse.find(`.//${this.mapReportRequestType(builder)}`);
        let result;
        if (builder.reportType === __1.ReportType.Activity) {
            result = doc
                .findall(".//Details")
                .map(this.hydrateTransactionSummary.bind(this));
        }
        if (builder.reportType === __1.ReportType.FindTransactions) {
            result = doc
                .findall(".//Transactions")
                .map(this.hydrateTransactionSummary.bind(this));
        }
        else if (builder.reportType === __1.ReportType.TransactionDetail) {
            result = this.hydrateTransactionSummary(doc);
        }
        return result;
    }
    normalizeResponse(input) {
        if (["0", "85"].indexOf(input) !== -1) {
            input = "00";
        }
        return input;
    }
    hasToken(paymentMethod) {
        const tokenizable = paymentMethod;
        if (tokenizable.token) {
            return {
                hasToken: true,
                tokenValue: tokenizable.token,
            };
        }
        return {
            hasToken: false,
            tokenValue: "",
        };
    }
    hydrateAccountType(type) {
        switch (type) {
            case __1.AccountType.Checking:
                return "CHECKING";
            case __1.AccountType.Savings:
                return "SAVINGS";
            default:
                return "";
        }
    }
    hydrateCheckType(type) {
        switch (type) {
            case __1.CheckType.Business:
                return "BUSINESS";
            case __1.CheckType.Payroll:
                return "PAYROLL";
            case __1.CheckType.Personal:
                return "PERSONAL";
            default:
                return "";
        }
    }
    hydrateCredentialOnFile(builder) {
        const cof = new elementtree_1.Element("CardOnFileData");
        if (builder.transactionInitiator) {
            (0, elementtree_1.SubElement)(cof, "CardOnFile").append((0, elementtree_1.CData)(builder.transactionInitiator));
        }
        if (builder.cardBrandTransactionId) {
            (0, elementtree_1.SubElement)(cof, "CardBrandTxnId").append((0, elementtree_1.CData)(builder.cardBrandTransactionId));
        }
        return cof;
    }
    hydrateEncryptionData(builder) {
        const enc = new elementtree_1.Element("EncryptionData");
        const data = builder.paymentMethod
            .encryptionData;
        if (data.version) {
            (0, elementtree_1.SubElement)(enc, "Version").append((0, elementtree_1.CData)(data.version));
        }
        if (data.trackNumber) {
            (0, elementtree_1.SubElement)(enc, "TrackNumber").append((0, elementtree_1.CData)(data.trackNumber));
        }
        if (data.ktb) {
            (0, elementtree_1.SubElement)(enc, "KTB").append((0, elementtree_1.CData)(data.ktb));
        }
        if (data.ksn) {
            (0, elementtree_1.SubElement)(enc, "KSN").append((0, elementtree_1.CData)(data.ksn));
        }
        return enc;
    }
    hydrateEntryMethod(method) {
        switch (method) {
            case __1.EntryMethod.Manual:
                return "Manual";
            case __1.EntryMethod.Proximity:
                return "Proximity";
            case __1.EntryMethod.Swipe:
                return "Swipe";
            default:
                return "";
        }
    }
    hydrateHolder(builder, isCheck) {
        const holder = new elementtree_1.Element(isCheck ? "ConsumerInfo" : "CardHolderData");
        (0, elementtree_1.SubElement)(holder, isCheck ? "Address1" : "CardHolderAddr").append((0, elementtree_1.CData)(builder.billingAddress.streetAddress1));
        (0, elementtree_1.SubElement)(holder, isCheck ? "City" : "CardHolderCity").append((0, elementtree_1.CData)(builder.billingAddress.city));
        (0, elementtree_1.SubElement)(holder, isCheck ? "State" : "CardHolderState").append((0, elementtree_1.CData)(builder.billingAddress.province));
        (0, elementtree_1.SubElement)(holder, isCheck ? "Zip" : "CardHolderZip").append((0, elementtree_1.CData)(builder.billingAddress.postalCode));
        if (isCheck) {
            const check = builder.paymentMethod;
            if (check.checkName) {
                const names = check.checkName.split(" ", 2);
                (0, elementtree_1.SubElement)(holder, "FirstName").append((0, elementtree_1.CData)(names[0]));
                if (names[1]) {
                    (0, elementtree_1.SubElement)(holder, "LastName").append((0, elementtree_1.CData)(names[1]));
                }
                (0, elementtree_1.SubElement)(holder, "CheckName").append((0, elementtree_1.CData)(check.checkName));
            }
            if (check.phoneNumber) {
                (0, elementtree_1.SubElement)(holder, "PhoneNumber").append((0, elementtree_1.CData)(check.phoneNumber));
            }
            if (check.driversLicenseNumber) {
                (0, elementtree_1.SubElement)(holder, "DLNumber").append((0, elementtree_1.CData)(check.driversLicenseNumber));
            }
            if (check.driversLicenseState) {
                (0, elementtree_1.SubElement)(holder, "DLState").append((0, elementtree_1.CData)(check.driversLicenseState));
            }
            if (check.ssnLast4 || check.birthYear) {
                const identity = (0, elementtree_1.SubElement)(holder, "IdentityInfo");
                (0, elementtree_1.SubElement)(identity, "SSNL4").append((0, elementtree_1.CData)(check.ssnLast4));
                (0, elementtree_1.SubElement)(identity, "DOBYear").append((0, elementtree_1.CData)(check.birthYear));
            }
        }
        return holder;
    }
    hydrateInquiryType(type) {
        switch (type) {
            case __1.InquiryType.Cash:
                return "CASH";
            case __1.InquiryType.Foodstamp:
                return "FOODSTAMP";
            case __1.InquiryType.Points:
                return "POINTS";
            case __1.InquiryType.Standard:
                return "STANDARD";
            default:
                return "";
        }
    }
    hydrateManualEntry(block1, builder, hasToken, tokenValue) {
        const me = new elementtree_1.Element(hasToken ? "TokenData" : "ManualEntry");
        let card;
        if (builder.paymentMethod instanceof __1.CreditCardData) {
            card = builder.paymentMethod;
        }
        else {
            card = builder.paymentMethod;
        }
        if (builder.cardBrandTransactionId || builder.transactionInitiator) {
            block1.append(this.hydrateCredentialOnFile(builder));
        }
        if (card.number || hasToken) {
            (0, elementtree_1.SubElement)(me, hasToken ? "TokenValue" : "CardNbr").append((0, elementtree_1.CData)(hasToken ? tokenValue : card.number));
        }
        if (card.expMonth) {
            (0, elementtree_1.SubElement)(me, "ExpMonth").append((0, elementtree_1.CData)(card.expMonth));
        }
        if (card.expYear) {
            (0, elementtree_1.SubElement)(me, "ExpYear").append((0, elementtree_1.CData)(card.expYear));
        }
        if (card.cvn) {
            (0, elementtree_1.SubElement)(me, "CVV2").append((0, elementtree_1.CData)(card.cvn));
        }
        (0, elementtree_1.SubElement)(me, "ReaderPresent").append((0, elementtree_1.CData)(card.readerPresent ? "Y" : "N"));
        (0, elementtree_1.SubElement)(me, "CardPresent").append((0, elementtree_1.CData)(card.cardPresent ? "Y" : "N"));
        if (builder.transactionModifier === __1.TransactionModifier.Recurring) {
            const recurring = (0, elementtree_1.SubElement)(block1, "RecurringData");
            (0, elementtree_1.SubElement)(recurring, "ScheduleID").append((0, elementtree_1.CData)(builder.scheduleId));
            (0, elementtree_1.SubElement)(recurring, "OneTime").append((0, elementtree_1.CData)(builder.oneTimePayment ? "Y" : "N"));
        }
        return me;
    }
    hydrateSecCode(code) {
        switch (code) {
            case __1.SecCode.CCD:
                return "CCD";
            case __1.SecCode.PPD:
                return "PPD";
            case __1.SecCode.POP:
                return "POP";
            case __1.SecCode.WEB:
                return "WEB";
            case __1.SecCode.TEL:
                return "TEL";
            case __1.SecCode.EBronze:
                return "EBRONZE";
            default:
                return "";
        }
    }
    hydrateTaxType(type) {
        switch (type) {
            case __1.TaxType.NotUsed:
                return "NOTUSED";
            case __1.TaxType.SalesTax:
                return "SALESTAX";
            case __1.TaxType.TaxExempt:
                return "TAXEXEMPT";
            default:
                return "";
        }
    }
    hydrateTrackData(builder, hasToken, tokenValue) {
        const trackData = new elementtree_1.Element(hasToken ? "TokenValue" : "TrackData");
        if (hasToken) {
            (0, elementtree_1.SubElement)(trackData, "TokenValue").append((0, elementtree_1.CData)(tokenValue));
            return trackData;
        }
        let track;
        if (builder.paymentMethod instanceof __1.CreditTrackData) {
            track = builder.paymentMethod;
        }
        else if (builder.paymentMethod instanceof __1.DebitTrackData) {
            track = builder.paymentMethod;
        }
        else {
            track = builder.paymentMethod;
        }
        trackData.append((0, elementtree_1.CData)(track.value));
        if (track.paymentMethodType !== __1.PaymentMethodType.Debit) {
            trackData.set("method", track.entryMethod === __1.EntryMethod.Swipe ? "swipe" : "proximity");
        }
        return trackData;
    }
    hydrateTransactionSummary(root) {
        const result = new __1.TransactionSummary();
        result.accountDataSource = root.findtext(".//AcctDataSrc");
        result.amount = root.findtext(".//Amt");
        result.authorizedAmount = root.findtext(".//AuthAmt");
        result.authCode = root.findtext(".//AuthCode");
        result.batchCloseDate = new Date(root.findtext(".//BatchCloseDT"));
        result.batchSequenceNumber = root.findtext(".//BatchSeqNbr");
        result.cardSwiped = root.findtext(".//CardSwiped");
        result.cardType = root.findtext(".//CardType");
        result.clerkId = root.findtext(".//ClerkID");
        result.clientTransactionId = root.findtext(".//ClientTxnId");
        result.convenienceAmt = root.findtext(".//ConvenienceAmtInfo");
        result.deviceId = root.findtext(".//DeviceId");
        result.gratuityAmount = root.findtext(".//GratuityAmtInfo");
        result.issuerResponseCode = this.normalizeResponse(root.findtext(".//IssuerRspCode"));
        result.issuerResponseMessage = root.findtext(".//IssuerRspText");
        result.issuerTransactionId = root.findtext(".//IssTxnId");
        result.maskedCardNumber = root.findtext(".//MaskedCardNbr");
        result.gatewayResponseCode = this.normalizeResponse(root.findtext(".//GatewayRspCode"));
        result.gatewayResponseMessage = root.findtext(".//GatewayRspMsg");
        result.originalTransactionId = root.findtext(".//OriginalGatewayTxnId");
        result.paymentType = root.findtext(".//PaymentType");
        result.poNumber = root.findtext(".//CardHolderPONbr");
        result.referenceNumber = root.findtext(".//RefNbr");
        result.responseDate = new Date(root.findtext(".//RspDT"));
        result.serviceName = root.findtext(".//ServiceName");
        result.settlementAmount = root.findtext(".//SettlementAmt");
        result.shippingAmt = root.findtext(".//ShippingAmtInfo");
        result.siteTrace = root.findtext(".//SiteTrace");
        result.status = root.findtext(".//TxnStatus");
        result.taxAmount = root.findtext(".//TaxAmtInfo");
        result.taxType = root.findtext(".//TaxType");
        result.transactionDate = new Date(root.findtext(".//TxnUtcDT"));
        result.transactionId = root.findtext(".//GatewayTxnId");
        result.username = root.findtext(".//UserName");
        result.description = root.findtext(".//Description");
        result.invoiceNumber = root.findtext(".//InvoiceNbr");
        result.customerId = root.findtext(".//CustomerID");
        result.uniqueDeviceId = root.findtext(".//UniqueDeviceId");
        result.transactionDescriptor = root.findtext(".//TxnDescriptor");
        result.giftCurrency = root.findtext(".//GiftCurrency");
        result.maskedAlias = root.findtext(".//GiftMaskedAlias");
        result.paymentMethodKey = root.findtext(".//PaymentMethodKey");
        result.scheduleId = root.findtext(".//ScheduleID");
        result.oneTimePayment = root.findtext(".//OneTime");
        result.recurringDataCode = root.findtext(".//RecurringDataCode");
        result.surchargeAmount = root.findtext(".//SurchargeAmtInfo");
        result.fraudRuleInfo = root.findtext(".//FraudInfoRule");
        result.repeatCount = root.findtext(".//RepeatCount");
        result.emvChipCondition = root.findtext(".//EMVChipCondition");
        result.hasEmvTags = root.findtext(".//HasEMVTag");
        result.hasEcomPaymentData = root.findtext(".//HasEComPaymentData");
        result.cavvResponseCode = root.findtext(".//CAVVResultCode");
        result.tokenPanLastFour = root.findtext(".//TokenPANLast4");
        result.companyName = root.findtext(".//Company");
        result.customerFirstName = root.findtext(".//CustomerFirstname");
        result.customerLastName = root.findtext(".//CustomerLastname");
        result.debtRepaymentIndicator = root.findtext(".//DebtRepaymentIndicator");
        result.captureAmount = root.findtext(".//CaptureAmtInfo");
        result.fullyCaptured = root.findtext(".//FullyCapturedInd");
        result.hasLevelIII = root.findtext(".//HasLevelIII");
        return result;
    }
    shouldIncludeCredentialOnFile(builder) {
        if ([
            __1.TransactionType.Auth,
            __1.TransactionType.Refund,
            __1.TransactionType.Sale,
            __1.TransactionType.Verify,
        ].indexOf(builder.transactionType) !== -1) {
            return true;
        }
        return false;
    }
    isAppleOrGooglePay(paymentDataSource) {
        return (paymentDataSource == __1.PaymentDataSourceType.APPLEPAY ||
            paymentDataSource == __1.PaymentDataSourceType.APPLEPAYAPP ||
            paymentDataSource == __1.PaymentDataSourceType.APPLEPAYWEB ||
            paymentDataSource == __1.PaymentDataSourceType.GOOGLEPAYAPP ||
            paymentDataSource == __1.PaymentDataSourceType.GOOGLEPAYWEB);
    }
}
exports.PorticoConnector = PorticoConnector;
const threeDSecureNumericVersion = (version) => {
    if (version === __1.Secure3dVersion.TWO)
        return "2";
    return "1";
};
// prettier-ignore
function buildLineItems(data, isVisa, items) {
    if (!items || items.length === 0) {
        return;
    }
    const lineItems = (0, elementtree_1.SubElement)(data, "LineItems");
    for (const item of items) {
        const lineItem = (0, elementtree_1.SubElement)(lineItems, "LineItemDetail");
        if (item.description !== undefined) {
            (0, elementtree_1.SubElement)(lineItem, "ItemDescription").append((0, elementtree_1.CData)(item.description));
        }
        if (item.productCode !== undefined) {
            (0, elementtree_1.SubElement)(lineItem, "ProductCode").append((0, elementtree_1.CData)(item.productCode));
        }
        if (item.quantity !== undefined) {
            (0, elementtree_1.SubElement)(lineItem, "Quantity").append((0, elementtree_1.CData)(item.quantity.toString()));
        }
        if (item.totalAmount !== undefined) {
            (0, elementtree_1.SubElement)(lineItem, "ItemTotalAmt").append((0, elementtree_1.CData)(item.totalAmount.toString()));
        }
        if (item.unitOfMeasure !== undefined) {
            (0, elementtree_1.SubElement)(lineItem, "UnitOfMeasure").append((0, elementtree_1.CData)(item.unitOfMeasure.toString()));
        }
        if (!isVisa) {
            continue;
        }
        if (item.commodityCode !== undefined) {
            (0, elementtree_1.SubElement)(lineItem, "ItemCommodityCode").append((0, elementtree_1.CData)(item.commodityCode));
        }
        if (item.unitCost !== undefined) {
            (0, elementtree_1.SubElement)(lineItem, "UnitCost").append((0, elementtree_1.CData)(item.unitCost.toString()));
        }
        if (item.taxAmount !== undefined) {
            (0, elementtree_1.SubElement)(lineItem, "VATTaxAmt").append((0, elementtree_1.CData)(item.taxAmount.toString()));
        }
        if (item.discountDetails?.discountAmount !== undefined) {
            (0, elementtree_1.SubElement)(lineItem, "DiscountAmt").append((0, elementtree_1.CData)(item.discountDetails.discountAmount.toString()));
        }
    }
}
//# sourceMappingURL=PorticoConnector.js.map