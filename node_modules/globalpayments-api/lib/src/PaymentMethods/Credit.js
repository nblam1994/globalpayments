"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Credit = void 0;
const __1 = require("../");
const PaymentMethod_1 = require("./PaymentMethod");
class Credit extends PaymentMethod_1.PaymentMethod {
    encryptionData;
    paymentMethodType = __1.PaymentMethodType.Credit;
    /**
     * The token value representing the card.
     *
     * For `TransactionModifier.EncryptedMobile` transactions, this value is the
     * encrypted payload from the mobile payment scheme.
     */
    token;
    /**
     * The type of mobile device used in `Transaction.Modifier.EncryptedMobile`
     * transactions.
     */
    mobileType;
    /**
     * Payment Source is the API or source of the cryptogram for WalletData.
     */
    paymentSource;
    cryptogram;
    eci;
    threeDSecure;
    /**
     * Authorizes the payment method
     *
     * @param string|number amount Amount to authorize
     *
     * @return AuthorizationBuilder
     */
    authorize(amount) {
        return new __1.AuthorizationBuilder(__1.TransactionType.Auth, this).withAmount(amount);
    }
    /**
     * Authorizes the payment method and captures the entire authorized amount
     *
     * @param string|number amount Amount to authorize
     *
     * @return AuthorizationBuilder
     */
    charge(amount) {
        return new __1.AuthorizationBuilder(__1.TransactionType.Sale, this).withAmount(amount);
    }
    /**
     * Adds value to the payment method
     *
     * @param string|number amount Amount to add
     *
     * @return AuthorizationBuilder
     */
    addValue(amount) {
        return new __1.AuthorizationBuilder(__1.TransactionType.AddValue, this).withAmount(amount);
    }
    /**
     * Inquires the balance of the payment method
     *
     * @param InquiryType inquiry Type of inquiry
     *
     * @return AuthorizationBuilder
     */
    balanceInquiry(inquiry) {
        return new __1.AuthorizationBuilder(__1.TransactionType.Balance, this).withBalanceInquiryType(inquiry);
    }
    /**
     * Refunds the payment method
     *
     * @param string|number amount Amount to refund
     *
     * @return AuthorizationBuilder
     */
    refund(amount) {
        return new __1.AuthorizationBuilder(__1.TransactionType.Refund, this).withAmount(amount);
    }
    /**
     * Reverses the payment method
     *
     * @param string|number amount Amount to reverse
     *
     * @return AuthorizationBuilder
     */
    reverse(amount) {
        return new __1.AuthorizationBuilder(__1.TransactionType.Reversal, this).withAmount(amount);
    }
    /**
     * Verifies the payment method
     *
     * @return AuthorizationBuilder
     */
    verify() {
        return new __1.AuthorizationBuilder(__1.TransactionType.Verify, this);
    }
    /**
     * Tokenizes the payment method
     *
     * @return AuthorizationBuilder
     */
    tokenize(verifyCard = true, usageMode = __1.PaymentMethodUsageMode.MULTIPLE) {
        if (verifyCard !== false) {
            verifyCard = true;
        }
        const type = verifyCard ? __1.TransactionType.Verify : __1.TransactionType.Tokenize;
        return new __1.AuthorizationBuilder(type, this)
            .withRequestMultiUseToken(true)
            .withPaymentMethodUsageMode(usageMode);
    }
    /**
     * Updates the token expiry date with the values proced to the card object
     *
     * @returns boolean value indicating success/failure
     */
    async updateTokenExpiry() {
        if (!this.token) {
            throw new __1.BuilderError("Token cannot be null");
        }
        await new __1.ManagementBuilder(__1.TransactionType.TokenUpdate)
            .withPaymentMethod(this)
            .execute();
        return true;
    }
    /**
     * Updates the payment token
     *
     * @returns ManagementBuilder
     */
    updateToken() {
        if (!this.token) {
            throw new __1.BuilderError("Token cannot be null");
        }
        return new __1.ManagementBuilder(__1.TransactionType.TokenUpdate).withPaymentMethod(this);
    }
    /**
     * Deletes the token associated with the current card object
     *
     * @returns boolean value indicating success/failure
     */
    async deleteToken() {
        if (!this.token) {
            throw new __1.BuilderError("Token cannot be null");
        }
        await new __1.ManagementBuilder(__1.TransactionType.TokenDelete)
            .withPaymentMethod(this)
            .execute();
        return true;
    }
    /**
     * Detokenizes the payment method
     *
     * @returns result of the detokenization
     */
    async detokenize() {
        if (!this.token) {
            throw new __1.BuilderError("Token cannot be null or empty");
        }
        return await new __1.ManagementBuilder(__1.TransactionType.Detokenize, this).execute();
    }
    getDccRate(dccRateType, ccp) {
        const authBuilder = new __1.AuthorizationBuilder(__1.TransactionType.DccRateLookup, this);
        if (dccRateType || ccp) {
            const dccRateData = new __1.DccRateData();
            if (ccp)
                dccRateData.dccProcessor = ccp;
            if (dccRateType)
                dccRateData.dccRateType = dccRateType;
            authBuilder.withDccRateData(dccRateData);
        }
        return authBuilder;
    }
}
exports.Credit = Credit;
//# sourceMappingURL=Credit.js.map