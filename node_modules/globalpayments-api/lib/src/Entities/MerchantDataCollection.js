"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MerchantDataCollection = void 0;
const MerchantKVP_1 = require("./MerchantKVP");
class MerchantDataCollection {
    collection;
    constructor() {
        this.collection = [];
    }
    add(key, value, visible = true) {
        if (this.hasKey(key)) {
            if (visible) {
                throw new Error(`Key ${key} already exists in the collection.`);
            }
            else {
                const index = this.indexOf(key);
                if (index !== -1) {
                    this.collection.splice(index, 1);
                }
            }
        }
        const kvp = new MerchantKVP_1.MerchantKVP();
        kvp.setKey(key);
        kvp.setValue(value);
        kvp.setVisible(visible);
        this.collection.push(kvp);
    }
    get(key) {
        const kvp = this.collection.find((item) => item.getKey() === key && item.isVisible());
        return kvp ? kvp.getValue() : null;
    }
    getKeys() {
        return this.collection
            .filter((item) => item.isVisible())
            .map((item) => item.getKey());
    }
    count() {
        return this.collection.filter((item) => item.isVisible()).length;
    }
    indexOf(key) {
        return this.collection.findIndex((item) => item.getKey() === key);
    }
    getHiddenValues() {
        return this.collection.filter((item) => !item.isVisible());
    }
    hasKey(key) {
        return this.get(key) !== null;
    }
    mergeHidden(oldCollection) {
        const hiddenValues = oldCollection.getHiddenValues();
        hiddenValues.forEach((kvp) => {
            if (!this.hasKey(kvp.getKey())) {
                this.collection.push(kvp);
            }
        });
    }
    static parse(kvpString, decoder = null) {
        const collection = new MerchantDataCollection();
        let decryptedKvp = atob(kvpString);
        if (decoder) {
            decryptedKvp = decoder(decryptedKvp);
        }
        const merchantData = decryptedKvp.split("|");
        merchantData.forEach((kvp) => {
            const data = kvp.split(":");
            collection.add(data[0], data[1], data[2] === "true");
        });
        return collection;
    }
    toString(encoder = null) {
        let sb = "";
        this.collection.forEach((kvp) => {
            sb += `${kvp.getKey()}:${kvp.getValue()}:${kvp.isVisible()}|`;
        });
        sb = sb.slice(0, -1);
        try {
            let formatted = sb;
            if (encoder) {
                formatted = encoder(sb);
            }
            return btoa(formatted);
        }
        catch (error) {
            return null;
        }
    }
    getValue(key, converter = null) {
        for (const kvp of this.collection) {
            if (kvp.getKey() === key) {
                if (converter !== null) {
                    return converter(kvp.getValue());
                }
                else {
                    return kvp.getValue();
                }
            }
        }
        return null;
    }
}
exports.MerchantDataCollection = MerchantDataCollection;
//# sourceMappingURL=MerchantDataCollection.js.map