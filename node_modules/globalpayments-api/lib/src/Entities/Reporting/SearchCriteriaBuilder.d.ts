import { Address, CardType, Channel, DisputeStage, DisputeStatus, FraudFilterMode, IPaymentMethod, PayByLinkStatus, PaymentEntryMode, PaymentMethodName, PaymentMethodType, PaymentMethodUsageMode, PaymentProvider, PaymentType, ReasonCode, TransactionReportBuilder, TransactionStatus, TransactionType } from "../../../src";
export declare class SearchCriteriaBuilder<T> {
    reportBuilder: TransactionReportBuilder<T>;
    accountId?: string;
    accountName?: string;
    accountNumberLastFour?: string;
    altPaymentStatus?: string;
    amount?: number;
    aquirerReferenceNumber?: string;
    authCode?: string;
    bankAccountNumber?: string;
    bankRoutingNumber?: string;
    batchId?: string;
    batchSequenceNumber?: string;
    brandReference?: string;
    buyerEmailAddress?: string;
    cardBrand?: string;
    cardHolderFirstName?: string;
    cardHolderLastName?: string;
    cardHolderPoNumber?: string;
    cardNumberFirstSix?: string;
    cardNumberLastFour?: string;
    cardTypes?: CardType[];
    channel?: Channel;
    checkFirstName?: string;
    checkLastName?: string;
    checkName?: string;
    checkNumber?: string;
    clerkId?: string;
    clientTransactionId?: string;
    country?: string;
    currency?: string;
    customerId?: string;
    depositId?: string;
    depositReference?: string;
    depositStatus?: string;
    displayName?: string;
    disputeId?: string | null;
    disputeDocumentId?: string;
    disputeStage?: DisputeStage;
    disputeStatus?: DisputeStatus;
    endBatchDate?: Date;
    endDate?: string;
    fromTimeLastUpdated?: string;
    toTimeLastUpdated?: string;
    endDepositDate?: Date;
    endStageDate?: Date;
    fullyCaptured?: boolean;
    giftCurrency?: string;
    giftMaskedAlias?: string;
    hierarchy?: string;
    invoiceNumber?: string;
    issuerResult?: string;
    issuerTransactionId?: string;
    localTransactionEndTime?: Date;
    localTransactionStartTime?: Date;
    merchantId?: string;
    name?: string;
    oneTime?: boolean;
    oderId?: string;
    paymentEntryMode?: PaymentEntryMode;
    paymentType?: PaymentType;
    paymentMethodName?: PaymentMethodName;
    paymentProvider?: PaymentProvider;
    paymentMethod?: IPaymentMethod;
    paymentMethodUsageMode?: PaymentMethodUsageMode;
    paymentMethodKey?: string;
    paymentMethodType?: PaymentMethodType;
    referenceNumber?: string;
    transactionType?: TransactionType[];
    settlementAmount?: number;
    settlementDisputeId?: string;
    storedPaymentMethodId?: string;
    storedPaymentMethodStatus?: string;
    scheduleId?: string;
    siteTrace?: string;
    startBatchDate?: Date;
    startDate?: string;
    startDepositDate?: Date;
    startStageDate?: Date;
    systemHierarchy?: string;
    tokenFirstSix?: string;
    tokenLastFour?: string;
    transactionStatus?: TransactionStatus;
    uniqueDeviceId?: string;
    username?: string;
    timezone?: string;
    actionId?: string;
    actionType?: string;
    resource?: string;
    resourceStatus?: string;
    resourceId?: string;
    merchantName?: string;
    appName?: string;
    version?: string;
    responseCode?: string;
    httpResponseCode?: string;
    payByLinkId: string;
    description?: string;
    expirationDate?: Date;
    payByLinkStatus?: PayByLinkStatus;
    address?: Address;
    bankPaymentId?: string;
    returnPii?: boolean;
    riskAssessmentMode?: FraudFilterMode;
    riskAssessmentReasonCode?: ReasonCode;
    constructor(reportBuilder: TransactionReportBuilder<T>);
    andWith(criteria: keyof this, value: any): this;
    execute(configName?: string): any;
}
