"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GpEcomConfig = void 0;
const Entities_1 = require("../../../src/Entities");
const GatewayConfig_1 = require("./GatewayConfig");
const Gateways_1 = require("../../../src/Gateways/");
class GpEcomConfig extends GatewayConfig_1.GatewayConfig {
    accountId;
    merchantId;
    rebatePassword;
    refundPassword;
    sharedSecret;
    channel;
    hostedPaymentConfig;
    shaHashType = Entities_1.ShaHashType.SHA1;
    // Secure 3D
    challengeNotificationUrl;
    methodNotificationUrl;
    merchantContactUrl;
    merchantNotificationUrl;
    constructor() {
        super(Entities_1.GatewayProvider.GpEcom);
    }
    configureContainer(services) {
        // parent::configureContainer(services); // must implement data services first
        if (!this.serviceUrl) {
            this.serviceUrl =
                this.environment == Entities_1.Environment.Test
                    ? Entities_1.ServiceEndpoints.GLOBAL_ECOM_TEST
                    : Entities_1.ServiceEndpoints.GLOBAL_ECOM_PRODUCTION;
        }
        const gateway = new Gateways_1.GpEcomConnector(this);
        gateway.timeout = this.timeout;
        gateway.hostedPaymentConfig = this.hostedPaymentConfig;
        gateway.serviceUrl = this.serviceUrl;
        gateway.requestLogger = this.requestLogger;
        services.gatewayConnector = gateway;
        services.recurringConnector = gateway;
    }
    validate() {
        super.validate();
        if (!this.merchantId) {
            throw new Entities_1.ConfigurationError("MerchantId is required for this gateway.");
        }
        if (!this.sharedSecret) {
            throw new Entities_1.ConfigurationError("SharedSecret is required for this gateway.");
        }
    }
}
exports.GpEcomConfig = GpEcomConfig;
//# sourceMappingURL=GpEcomConfig.js.map